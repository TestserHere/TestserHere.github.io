<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Real-Time Maps</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .search-box {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .search-box input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
        }

        .search-box input:focus {
            border-color: #4285f4;
        }

        .search-box button {
            padding: 12px 20px;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
        }

        .search-box button:hover {
            background: #3367d6;
        }

        .location-btn {
            width: 100%;
            padding: 12px;
            background: #34a853;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .location-btn:hover {
            background: #2d8f47;
        }

        .location-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }

        .directions-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            border-radius: 12px;
            padding: 16px;
            max-height: 40vh;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: none;
        }

        .directions-panel.show {
            display: block;
        }

        .direction-step {
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .direction-step:hover {
            background: #f5f5f5;
        }

        .step-instruction {
            font-weight: 500;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .step-distance {
            font-size: 12px;
            color: #666;
        }

        /* Navigation Mode */
        .navigation-banner {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: #1a1a1a;
            color: white;
            border-radius: 12px;
            padding: 16px;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .navigation-banner.show {
            display: block;
        }

        .nav-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-direction-icon {
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #1a1a1a;
            font-weight: bold;
        }

        .nav-instruction-text {
            flex: 1;
        }

        .nav-main-instruction {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .nav-sub-instruction {
            font-size: 14px;
            color: #b0b0b0;
        }

        .nav-distance {
            font-size: 16px;
            font-weight: 600;
            color: #4285f4;
        }

        .nav-controls {
            display: flex;
            gap: 8px;
        }

        .nav-btn {
            padding: 8px 12px;
            background: white;
            color: #1a1a1a;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
        }

        .nav-btn.exit {
            background: #ea4335;
            color: white;
        }

        .directions-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            background: white;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .directions-toggle.show {
            display: flex;
        }

        .start-navigation-btn {
            width: 100%;
            padding: 12px;
            background: #34a853;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            margin-top: 8px;
        }

        .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .controls {
                top: 5px;
                left: 5px;
                right: 5px;
                padding: 10px;
                border-radius: 8px;
            }
            
            .search-box {
                margin-bottom: 8px;
            }
            
            .search-box input {
                padding: 12px 14px;
                font-size: 16px; /* Prevents zoom on iOS */
                border-radius: 6px;
            }
            
            .search-box button {
                padding: 12px 16px;
                font-size: 14px;
                border-radius: 6px;
                min-width: 80px;
            }
            
            .location-btn {
                padding: 12px;
                font-size: 14px;
                border-radius: 6px;
            }
            
            .location-info {
                font-size: 11px;
                line-height: 1.3;
            }
            
            .directions-panel {
                bottom: 5px;
                left: 5px;
                right: 5px;
                padding: 12px;
                max-height: 40vh;
                border-radius: 8px;
            }
            
            .direction-step {
                padding: 10px;
                margin-bottom: 2px;
            }
            
            .step-instruction {
                font-size: 14px;
                line-height: 1.3;
            }
            
            .step-distance {
                font-size: 11px;
                margin-top: 2px;
            }
            
            .start-navigation-btn {
                padding: 14px;
                font-size: 16px;
                margin-top: 10px;
                border-radius: 6px;
            }
            
            .navigation-banner {
                top: 5px;
                left: 5px;
                right: 5px;
                padding: 12px;
                border-radius: 8px;
            }
            
            .nav-content {
                gap: 10px;
            }
            
            .nav-direction-icon {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }
            
            .nav-main-instruction {
                font-size: 16px;
                line-height: 1.2;
            }
            
            .nav-sub-instruction {
                font-size: 12px;
                line-height: 1.2;
            }
            
            .nav-distance {
                font-size: 14px;
                min-width: 50px;
                text-align: right;
            }
            
            .nav-btn {
                padding: 10px 12px;
                font-size: 11px;
                border-radius: 4px;
            }
            
            .directions-toggle {
                bottom: 5px;
                right: 5px;
                width: 52px;
                height: 52px;
                font-size: 20px;
                border-radius: 50%;
            }
            
            .status {
                padding: 10px 16px;
                font-size: 14px;
                border-radius: 6px;
                max-width: 90vw;
                text-align: center;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .controls {
                padding: 8px;
            }
            
            .search-box input {
                padding: 10px 12px;
                font-size: 16px;
            }
            
            .search-box button {
                padding: 10px 12px;
                font-size: 12px;
                min-width: 70px;
            }
            
            .location-btn {
                padding: 10px;
                font-size: 13px;
            }
            
            .nav-main-instruction {
                font-size: 14px;
            }
            
            .nav-sub-instruction {
                font-size: 11px;
            }
            
            .nav-distance {
                font-size: 12px;
                min-width: 40px;
            }
        }

        /* Landscape orientation */
        @media (max-width: 768px) and (orientation: landscape) {
            .directions-panel {
                max-height: 30vh;
            }
            
            .navigation-banner {
                top: 5px;
                left: 5px;
                right: 5px;
                padding: 8px;
            }
            
            .nav-main-instruction {
                font-size: 14px;
            }
            
            .nav-sub-instruction {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="controls">
        <div class="search-box">
            <input type="text" id="destination" placeholder="Search for a destination...">
            <button onclick="getDirections()">Get Directions</button>
        </div>
        <button class="location-btn" onclick="getCurrentLocation()">üìç Get My Location</button>
        <div class="location-info" id="location-info">Click to get your location</div>
    </div>

    <div class="directions-panel" id="directions-panel">
        <h3>Directions</h3>
        <div id="directions-list"></div>
        <button class="start-navigation-btn" onclick="startNavigation()" id="start-navigation-btn">
            üöó Start Navigation
        </button>
    </div>

    <!-- Navigation Banner -->
    <div class="navigation-banner" id="navigation-banner">
        <div class="nav-content">
            <div class="nav-direction-icon" id="nav-direction-icon">‚Üí</div>
            <div class="nav-instruction-text">
                <div class="nav-main-instruction" id="nav-main-instruction">Ready to navigate</div>
                <div class="nav-sub-instruction" id="nav-sub-instruction">Tap to start</div>
            </div>
            <div class="nav-distance" id="nav-distance">-- m</div>
            <div class="nav-controls">
                <button class="nav-btn" id="voice-toggle" onclick="toggleVoice()" title="Voice On">üîä</button>
                <button class="nav-btn" onclick="toggleDirections()">üìã</button>
                <button class="nav-btn exit" onclick="stopNavigation()">Exit</button>
            </div>
        </div>
    </div>

    <!-- Directions Toggle Button -->
    <button class="directions-toggle" onclick="toggleDirections()" id="directions-toggle">
        üìã
    </button>

    <div class="status" id="status"></div>

    <script>
        let map;
        let currentMarker;
        let destinationMarker;
        let routeLine;
        let locationWatchId;
        let isTracking = false;
        let currentPosition;
        let destination;
        let route;
        let isNavigating = false;
        let currentStep = 0;
        let navigationWatchId;
        let speechSynthesis;
        let voiceEnabled = true;
        let lastSpokenInstruction = '';
        let spokenInstructions = new Set();
        let lastStepSpoken = -1;
        let carSymbol;
        let userHeading = 0;

        // Initialize the map
        function initMap() {
            map = L.map('map').setView([-37.8136, 144.9631], 13); // Melbourne

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Initialize speech synthesis
            initSpeechSynthesis();
        }

        // Initialize speech synthesis
        function initSpeechSynthesis() {
            if ('speechSynthesis' in window) {
                speechSynthesis = window.speechSynthesis;
                
                // Wait for voices to load
                speechSynthesis.onvoiceschanged = function() {
                    console.log('Speech synthesis ready');
                };
                
                console.log('Speech synthesis initialized');
            } else {
                console.log('Speech synthesis not supported');
                voiceEnabled = false;
            }
        }

        // Speak navigation instruction
        function speakInstruction(instruction, distance = null, force = false) {
            if (!voiceEnabled || !speechSynthesis) return;
            
            // Don't repeat the same instruction unless forced
            if (instruction === lastSpokenInstruction && !force) return;
            
            let textToSpeak = instruction;
            
            // Add distance if provided
            if (distance && distance > 0) {
                if (distance < 1000) {
                    textToSpeak = `In ${Math.round(distance)} meters, ${instruction}`;
                } else {
                    textToSpeak = `In ${(distance / 1000).toFixed(1)} kilometers, ${instruction}`;
                }
            }
            
            // Stop any current speech
            speechSynthesis.cancel();
            
            // Create speech utterance
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            
            // Configure voice settings
            utterance.rate = 0.9; // Slightly slower for clarity
            utterance.pitch = 1.0;
            utterance.volume = 0.8;
            
            // Try to use a good voice
            const voices = speechSynthesis.getVoices();
            const preferredVoices = ['Google UK English Female', 'Google UK English Male', 'Samantha', 'Alex'];
            
            for (const voiceName of preferredVoices) {
                const voice = voices.find(v => v.name.includes(voiceName));
                if (voice) {
                    utterance.voice = voice;
                    break;
                }
            }
            
            // Speak the instruction
            speechSynthesis.speak(utterance);
            lastSpokenInstruction = instruction;
            
            console.log('Speaking:', textToSpeak);
        }

        // Create car symbol for navigation
        function createCarSymbol() {
            if (carSymbol) {
                map.removeLayer(carSymbol);
            }
            
            // Create a custom car icon
            const carIcon = L.divIcon({
                className: 'car-symbol',
                html: `
                    <div style="
                        width: 24px;
                        height: 24px;
                        background: #4285f4;
                        border: 3px solid white;
                        border-radius: 50%;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        position: relative;
                        transform: rotate(${userHeading}deg);
                    ">
                        <div style="
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            width: 0;
                            height: 0;
                            border-left: 6px solid transparent;
                            border-right: 6px solid transparent;
                            border-bottom: 8px solid white;
                            transform: translate(-50%, -50%);
                        "></div>
                    </div>
                `,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            carSymbol = L.marker([currentPosition.lat, currentPosition.lng], {
                icon: carIcon,
                zIndexOffset: 1000
            }).addTo(map);
            
            console.log('Car symbol created');
        }

        // Calculate heading from movement
        let lastPosition = null;
        function calculateHeadingFromMovement(currentPos) {
            if (!lastPosition) {
                lastPosition = currentPos;
                return null;
            }
            
            const deltaLat = currentPos.lat - lastPosition.lat;
            const deltaLng = currentPos.lng - lastPosition.lng;
            
            if (Math.abs(deltaLat) < 0.00001 && Math.abs(deltaLng) < 0.00001) {
                return null; // Not moving
            }
            
            const heading = Math.atan2(deltaLng, deltaLat) * 180 / Math.PI;
            lastPosition = currentPos;
            
            return heading;
        }

        // Update car symbol position and rotation
        function updateCarSymbol(position, heading = null) {
            if (!carSymbol) return;
            
            // Update position
            carSymbol.setLatLng([position.lat, position.lng]);
            
            // Update heading if provided
            if (heading !== null) {
                userHeading = heading;
            } else {
                // Calculate heading from movement if GPS heading not available
                const calculatedHeading = calculateHeadingFromMovement(position);
                if (calculatedHeading !== null) {
                    userHeading = calculatedHeading;
                }
            }
            
            // Update the car symbol rotation
            const iconElement = carSymbol.getElement();
            if (iconElement) {
                const carDiv = iconElement.querySelector('.car-symbol');
                if (carDiv) {
                    carDiv.style.transform = `rotate(${userHeading}deg)`;
                }
            }
        }

        // Toggle voice on/off
        function toggleVoice() {
            voiceEnabled = !voiceEnabled;
            const voiceBtn = document.getElementById('voice-toggle');
            if (voiceBtn) {
                voiceBtn.textContent = voiceEnabled ? 'üîä' : 'üîá';
                voiceBtn.title = voiceEnabled ? 'Voice On' : 'Voice Off';
            }
            
            if (!voiceEnabled) {
                speechSynthesis.cancel();
            }
            
            showStatus(voiceEnabled ? 'Voice enabled' : 'Voice disabled');
            setTimeout(hideStatus, 1500);
        }

        // Get current location with high precision
        function getCurrentLocation() {
            showStatus('Getting your location...');
            
            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;

                    currentPosition = { lat, lng };
                    
                    // Update or create marker
                    if (currentMarker) {
                        map.removeLayer(currentMarker);
                    }
                    
                    currentMarker = L.marker([lat, lng], {
                        icon: L.divIcon({
                            className: 'current-location-marker',
                            html: '<div style="background: #4285f4; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        })
                    }).addTo(map);

                    // Add accuracy circle
                    const accuracyCircle = L.circle([lat, lng], {
                        radius: accuracy,
                        color: '#4285f4',
                        fillColor: '#4285f4',
                        fillOpacity: 0.1,
                        weight: 1
                    }).addTo(map);

                    // Center map on location
                    map.setView([lat, lng], 16);
                    
                    // Update location info
                    updateLocationInfo(accuracy);
                    
                    // Get address
                    getAddressFromCoords(lat, lng);
                    
                    hideStatus();
                    showStatus('Location found!');
                    setTimeout(hideStatus, 2000);
                },
                (error) => {
                    console.error('Location error:', error);
                    hideStatus();
                    showStatus('Could not get location. Please try again.');
                    setTimeout(hideStatus, 3000);
                },
                options
            );
        }

        // Start real-time location tracking
        function startLocationTracking() {
            if (locationWatchId) {
                navigator.geolocation.clearWatch(locationWatchId);
            }

            locationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    const heading = position.coords.heading;

                    currentPosition = { lat, lng };
                    
                    // Update heading if available
                    if (heading !== null && !isNaN(heading)) {
                        userHeading = heading;
                    }
                    
                    // Update marker position
                    if (currentMarker) {
                        currentMarker.setLatLng([lat, lng]);
                    }
                    
                    // Update car symbol if in navigation mode
                    if (isNavigating && carSymbol) {
                        updateCarSymbol(currentPosition, userHeading);
                    }
                    
                    // Update location info
                    updateLocationInfo(accuracy);
                },
                (error) => {
                    console.error('Location tracking error:', error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 1000
                }
            );
        }

        // Update location info display
        function updateLocationInfo(accuracy) {
            const locationInfo = document.getElementById('location-info');
            let accuracyText = '';
            
            if (accuracy <= 5) {
                accuracyText = `Ultra High (${accuracy.toFixed(1)}m)`;
            } else if (accuracy <= 20) {
                accuracyText = `High (${accuracy.toFixed(1)}m)`;
            } else if (accuracy <= 50) {
                accuracyText = `Medium (${accuracy.toFixed(1)}m)`;
            } else {
                accuracyText = `Low (${accuracy.toFixed(1)}m)`;
            }
            
            locationInfo.textContent = `üìç Location: ${currentPosition.lat.toFixed(6)}, ${currentPosition.lng.toFixed(6)} ‚Ä¢ ${accuracyText}`;
        }

        // Get address from coordinates
        async function getAddressFromCoords(lat, lng) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`, {
                    timeout: 5000
                });
                const data = await response.json();
                
                if (data.display_name) {
                    const locationInfo = document.getElementById('location-info');
                    locationInfo.textContent += ` ‚Ä¢ ${data.display_name.split(',')[0]}`;
                }
            } catch (error) {
                console.error('Error getting address:', error);
            }
        }

        // Get directions
        async function getDirections() {
            const destinationInput = document.getElementById('destination').value.trim();
            
            if (!destinationInput) {
                showStatus('Please enter a destination');
                setTimeout(hideStatus, 2000);
                return;
            }

            if (!currentPosition) {
                showStatus('Please get your location first');
                setTimeout(hideStatus, 2000);
                return;
            }

            showStatus('Finding destination...');
            
            try {
                // Geocode destination
                const geocoded = await geocodeDestination(destinationInput);
                if (!geocoded) {
                    showStatus('Could not find destination');
                    setTimeout(hideStatus, 2000);
                    return;
                }

                destination = geocoded;
                showStatus('Calculating route...');
                
                // Calculate route
                await calculateRoute();
                
            } catch (error) {
                console.error('Error getting directions:', error);
                showStatus('Error getting directions');
                setTimeout(hideStatus, 2000);
            }
        }

        // Geocode destination with fallback
        async function geocodeDestination(address) {
            const searchStrategies = [
                address,
                `${address}, Melbourne`,
                `${address}, Victoria, Australia`
            ];

            for (const searchTerm of searchStrategies) {
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchTerm)}&limit=1&addressdetails=1`, {
                        timeout: 5000
                    });
                    const data = await response.json();

                    if (data && data.length > 0) {
                        const result = data[0];
                        return {
                            lat: parseFloat(result.lat),
                            lng: parseFloat(result.lon),
                            name: result.display_name
                        };
                    }
                } catch (error) {
                    console.error('Geocoding error:', error);
                }
            }

            return null;
        }

        // Calculate route
        async function calculateRoute() {
            if (!currentPosition || !destination) {
                showStatus('Please get your location and destination first');
                setTimeout(hideStatus, 2000);
                return;
            }

            showStatus('Calculating route...');

            const url = `https://router.project-osrm.org/route/v1/driving/${currentPosition.lng},${currentPosition.lat};${destination.lng},${destination.lat}?overview=full&steps=true&annotations=true&geometries=geojson`;

            try {
                const response = await fetch(url, { timeout: 10000 });
                const data = await response.json();

                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    route = data;
                    displayRoute(data);
                    displayDirections(data);
                    showStatus('Route calculated successfully!');
                    setTimeout(hideStatus, 2000);
                } else {
                    showStatus('No route found');
                    setTimeout(hideStatus, 2000);
                }
            } catch (error) {
                console.error('Routing error:', error);
                showStatus('Error calculating route');
                setTimeout(hideStatus, 2000);
            }
        }

        // Display route on map with road-following geometry
        function displayRoute(data) {
            try {
                // Clear existing route
                if (routeLine) {
                    map.removeLayer(routeLine);
                }
                if (destinationMarker) {
                    map.removeLayer(destinationMarker);
                }

                // Add destination marker
                destinationMarker = L.marker([destination.lat, destination.lng], {
                    icon: L.divIcon({
                        className: 'destination-marker',
                        html: '<div style="background: #dc3545; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);

                // Try to get road-following geometry
                let coordinates = null;
                
                // Method 1: Try to use GeoJSON geometry (most accurate)
                if (data.routes[0].geometry && data.routes[0].geometry.type === 'LineString') {
                    coordinates = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    console.log('Using GeoJSON geometry for road following');
                }
                // Method 2: Try to decode polyline geometry
                else if (data.routes[0].geometry && typeof data.routes[0].geometry === 'string') {
                    try {
                        coordinates = decodePolyline(data.routes[0].geometry);
                        console.log('Using polyline geometry for road following');
                    } catch (e) {
                        console.log('Polyline decode failed, trying step geometry');
                    }
                }
                
                // Method 2: Try to use step geometry if available
                if (!coordinates && data.routes[0].legs[0].steps) {
                    coordinates = createRouteFromStepGeometry(data.routes[0].legs[0].steps);
                    if (coordinates && coordinates.length > 1) {
                        console.log('Using step geometry for road following');
                    }
                }
                
                // Method 3: Fallback to step coordinates
                if (!coordinates || coordinates.length < 2) {
                    coordinates = createRouteFromSteps(data.routes[0].legs[0].steps);
                    console.log('Using step coordinates as fallback');
                }

                console.log('Final route coordinates:', coordinates);

                // Create route line
                if (coordinates && coordinates.length > 1) {
                    routeLine = L.polyline(coordinates, {
                        color: '#4285f4',
                        weight: 6,
                        opacity: 0.8
                    }).addTo(map);

                    // Fit map to route
                    map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
                } else {
                    // Fallback: simple line between start and end
                    const fallbackCoordinates = [
                        [currentPosition.lat, currentPosition.lng],
                        [destination.lat, destination.lng]
                    ];
                    routeLine = L.polyline(fallbackCoordinates, {
                        color: '#4285f4',
                        weight: 6,
                        opacity: 0.8
                    }).addTo(map);
                    map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
                }
            } catch (error) {
                console.error('Error displaying route:', error);
                // Fallback: just show markers
                if (destinationMarker) {
                    map.fitBounds([
                        [currentPosition.lat, currentPosition.lng],
                        [destination.lat, destination.lng]
                    ], { padding: [20, 20] });
                }
            }
        }

        // Create route from step geometry (road-following)
        function createRouteFromStepGeometry(steps) {
            const coordinates = [];
            
            // Add starting point
            if (currentPosition) {
                coordinates.push([currentPosition.lat, currentPosition.lng]);
            }
            
            // Extract geometry from each step
            steps.forEach(step => {
                if (step.geometry && step.geometry.coordinates) {
                    // Add all coordinates from step geometry
                    step.geometry.coordinates.forEach(coord => {
                        // OSRM uses [lng, lat] format, convert to [lat, lng] for Leaflet
                        coordinates.push([coord[1], coord[0]]);
                    });
                } else if (step.maneuver && step.maneuver.location) {
                    // Fallback to maneuver location if no geometry
                    const location = step.maneuver.location;
                    coordinates.push([location[1], location[0]]);
                }
            });
            
            // Add destination
            if (destination) {
                coordinates.push([destination.lat, destination.lng]);
            }
            
            // Remove duplicate coordinates
            const uniqueCoordinates = [];
            coordinates.forEach(coord => {
                const exists = uniqueCoordinates.some(existing => 
                    Math.abs(existing[0] - coord[0]) < 0.0001 && 
                    Math.abs(existing[1] - coord[1]) < 0.0001
                );
                if (!exists) {
                    uniqueCoordinates.push(coord);
                }
            });
            
            console.log('Created road-following route with', uniqueCoordinates.length, 'points');
            return uniqueCoordinates;
        }

        // Create route from step coordinates (reliable method)
        function createRouteFromSteps(steps) {
            const coordinates = [];
            
            // Add starting point
            if (currentPosition) {
                coordinates.push([currentPosition.lat, currentPosition.lng]);
            }
            
            // Add step coordinates
            steps.forEach(step => {
                if (step.maneuver && step.maneuver.location) {
                    const location = step.maneuver.location;
                    // OSRM uses [lng, lat] format, convert to [lat, lng] for Leaflet
                    coordinates.push([location[1], location[0]]);
                }
            });
            
            // Add destination
            if (destination) {
                coordinates.push([destination.lat, destination.lng]);
            }
            
            // Remove duplicate coordinates
            const uniqueCoordinates = [];
            coordinates.forEach(coord => {
                const exists = uniqueCoordinates.some(existing => 
                    Math.abs(existing[0] - coord[0]) < 0.0001 && 
                    Math.abs(existing[1] - coord[1]) < 0.0001
                );
                if (!exists) {
                    uniqueCoordinates.push(coord);
                }
            });
            
            console.log('Created route with', uniqueCoordinates.length, 'points');
            return uniqueCoordinates;
        }

        // Display directions
        function displayDirections(data) {
            const directionsPanel = document.getElementById('directions-panel');
            const directionsList = document.getElementById('directions-list');
            
            directionsPanel.classList.add('show');
            directionsList.innerHTML = '';

            const route = data.routes[0];
            const leg = route.legs[0];
            const steps = leg.steps;

            // Add route summary
            const summaryDiv = document.createElement('div');
            summaryDiv.style.cssText = 'background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px; border-left: 4px solid #4285f4;';
            summaryDiv.innerHTML = `
                <strong>Route Summary</strong><br>
                Distance: ${(leg.distance / 1000).toFixed(1)} km<br>
                Time: ${Math.round(leg.duration / 60)} minutes
            `;
            directionsList.appendChild(summaryDiv);

            steps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'direction-step';
                stepDiv.onclick = () => highlightStep(index, step);
                
                // Get better instruction text
                const instruction = getBetterInstruction(step);
                const distance = step.distance || 0;
                const duration = step.duration || 0;
                
                // Get road names
                const currentRoad = step.name || step.maneuver.name || '';
                const nextRoad = step.maneuver.after || '';
                
                stepDiv.innerHTML = `
                    <div class="step-instruction">${instruction}</div>
                    <div class="step-distance">${distance.toFixed(0)}m ‚Ä¢ ${Math.round(duration)}s</div>
                    ${currentRoad ? `<div style="font-size: 12px; color: #888; margin-top: 2px;">${currentRoad}${nextRoad && nextRoad !== currentRoad ? ` ‚Üí ${nextRoad}` : ''}</div>` : ''}
                `;
                
                directionsList.appendChild(stepDiv);
            });
        }

        // Get better instruction text
        function getBetterInstruction(step) {
            const maneuver = step.maneuver;
            const maneuverType = maneuver.type;
            const instruction = maneuver.instruction || '';
            
            // If instruction is already good, use it
            if (instruction && instruction !== 'Continue' && instruction !== 'Head') {
                return instruction;
            }
            
            // Generate better instruction based on maneuver type
            let betterInstruction = '';
            
            switch(maneuverType) {
                case 'turn-right':
                    betterInstruction = 'Turn right';
                    break;
                case 'turn-left':
                    betterInstruction = 'Turn left';
                    break;
                case 'turn-slight-right':
                    betterInstruction = 'Slight right';
                    break;
                case 'turn-slight-left':
                    betterInstruction = 'Slight left';
                    break;
                case 'turn-sharp-right':
                    betterInstruction = 'Sharp right';
                    break;
                case 'turn-sharp-left':
                    betterInstruction = 'Sharp left';
                    break;
                case 'uturn':
                    betterInstruction = 'Make a U-turn';
                    break;
                case 'arrive':
                    betterInstruction = 'You have arrived';
                    break;
                default:
                    betterInstruction = 'Continue';
            }
            
            // Add road name if available
            const roadName = step.name || step.maneuver.name || '';
            if (roadName && maneuverType !== 'arrive') {
                betterInstruction += ` on ${roadName}`;
            }
            
            return betterInstruction;
        }

        // Highlight step on map
        function highlightStep(index, step) {
            if (step.maneuver && step.maneuver.location) {
                const location = step.maneuver.location;
                map.setView([location[1], location[0]], 16);
            }
        }

        // Start navigation mode
        function startNavigation() {
            if (!route) {
                showStatus('Please get directions first');
                setTimeout(hideStatus, 2000);
                return;
            }

            isNavigating = true;
            currentStep = 0;
            lastSpokenInstruction = ''; // Reset spoken instructions
            spokenInstructions.clear(); // Reset instruction tracking
            lastStepSpoken = -1; // Reset step tracking

            // Hide search controls
            document.querySelector('.controls').style.display = 'none';
            
            // Hide directions panel
            document.getElementById('directions-panel').classList.remove('show');
            
            // Show navigation banner
            document.getElementById('navigation-banner').classList.add('show');
            
            // Show directions toggle
            document.getElementById('directions-toggle').classList.add('show');

            // Create car symbol
            createCarSymbol();

            // Start navigation tracking
            startNavigationTracking();

            // Show first instruction
            updateNavigationDisplay();

            // Center map on user
            if (currentPosition) {
                map.setView([currentPosition.lat, currentPosition.lng], 18);
            }

            // Speak initial instruction
            speakInstruction('Navigation started. Follow the route ahead.');

            showStatus('Navigation started!');
            setTimeout(hideStatus, 2000);
        }

        // Stop navigation
        function stopNavigation() {
            isNavigating = false;

            // Stop any ongoing speech
            if (speechSynthesis) {
                speechSynthesis.cancel();
            }

            // Stop navigation tracking
            if (navigationWatchId) {
                navigator.geolocation.clearWatch(navigationWatchId);
                navigationWatchId = null;
            }

            // Remove destination marker (red dot)
            if (destinationMarker) {
                map.removeLayer(destinationMarker);
                destinationMarker = null;
            }

            // Remove route line
            if (routeLine) {
                map.removeLayer(routeLine);
                routeLine = null;
            }

            // Remove car symbol
            if (carSymbol) {
                map.removeLayer(carSymbol);
                carSymbol = null;
            }

            // Show search controls
            document.querySelector('.controls').style.display = 'block';
            
            // Hide navigation elements
            document.getElementById('navigation-banner').classList.remove('show');
            document.getElementById('directions-toggle').classList.remove('show');
            document.getElementById('directions-panel').classList.remove('show');

            // Clear route data
            route = null;
            destination = null;

            showStatus('Navigation stopped');
            setTimeout(hideStatus, 2000);
        }

        // Start navigation tracking
        function startNavigationTracking() {
            if (navigationWatchId) {
                navigator.geolocation.clearWatch(navigationWatchId);
            }

            navigationWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    if (isNavigating) {
                        const newPosition = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        const heading = position.coords.heading;
                        
                        currentPosition = newPosition;
                        
                        // Update car symbol with heading
                        updateCarSymbol(newPosition, heading);
                        
                        updateNavigation(newPosition);
                    }
                },
                (error) => {
                    console.error('Navigation tracking error:', error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 1000
                }
            );
        }

        // Update navigation display
        function updateNavigation(userPosition) {
            if (!route || !isNavigating) return;

            const steps = route.routes[0].legs[0].steps;
            
            // Get current street name from reverse geocoding
            getCurrentStreetName(userPosition).then(currentStreet => {
                console.log('Current street:', currentStreet);
                
                // Find current step based on street name and proximity
                let newCurrentStep = findCurrentStepByStreet(steps, currentStreet, userPosition);
                
                // If we found a new step, update
                if (newCurrentStep !== currentStep && newCurrentStep < steps.length) {
                    console.log(`Step changed from ${currentStep} to ${newCurrentStep}`);
                    currentStep = newCurrentStep;
                    updateNavigationDisplay();
                }
                
                // Update distance to next turn
                const nextStep = steps[currentStep];
                const distanceToNext = calculateDistance(
                    userPosition.lat, userPosition.lng,
                    nextStep.maneuver.location[1], nextStep.maneuver.location[0]
                );

                document.getElementById('nav-distance').textContent = `${Math.round(distanceToNext)}m`;
                
                // Voice alerts based on distance and street matching
                if (distanceToNext <= 100 && distanceToNext > 50) {
                    // Check if we're on the correct street for this turn
                    const stepStreet = nextStep.name || nextStep.maneuver.name || '';
                    if (currentStreet && stepStreet && currentStreet.toLowerCase().includes(stepStreet.toLowerCase())) {
                        const instruction = getBetterInstruction(nextStep);
                        speakInstruction(instruction, distanceToNext);
                    }
                } else if (distanceToNext <= 50) {
                    // Final alert when very close to turn
                    const instruction = getBetterInstruction(nextStep);
                    speakInstruction(instruction, distanceToNext);
                }
            });
        }

        // Get current street name using reverse geocoding
        async function getCurrentStreetName(position) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${position.lat}&lon=${position.lng}&zoom=18&addressdetails=1`, {
                    timeout: 5000
                });
                const data = await response.json();
                
                if (data.address) {
                    // Try different address fields for street name
                    return data.address.road || 
                           data.address.street || 
                           data.address.highway || 
                           data.address.name ||
                           data.display_name.split(',')[0];
                }
                return null;
            } catch (error) {
                console.error('Error getting street name:', error);
                return null;
            }
        }

        // Find current step based on street name and proximity
        function findCurrentStepByStreet(steps, currentStreet, userPosition) {
            if (!currentStreet) {
                // Fallback to proximity-based detection
                return findCurrentStepByProximity(steps, userPosition);
            }
            
            // First, try to find step by street name
            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                const stepStreet = step.name || step.maneuver.name || '';
                
                if (stepStreet && currentStreet.toLowerCase().includes(stepStreet.toLowerCase())) {
                    console.log(`Found step ${i} by street name: ${stepStreet} matches ${currentStreet}`);
                    return i;
                }
            }
            
            // If no street match, use proximity with more conservative distance
            return findCurrentStepByProximity(steps, userPosition);
        }

        // Find current step by proximity (fallback method)
        function findCurrentStepByProximity(steps, userPosition) {
            let closestStep = currentStep; // Start with current step
            let minDistance = Infinity;
            
            // Check steps around current step (within 3 steps)
            const startIndex = Math.max(0, currentStep - 2);
            const endIndex = Math.min(steps.length - 1, currentStep + 2);
            
            for (let i = startIndex; i <= endIndex; i++) {
                const step = steps[i];
                const stepLocation = step.maneuver.location;
                const distance = calculateDistance(
                    userPosition.lat, userPosition.lng,
                    stepLocation[1], stepLocation[0]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestStep = i;
                }
            }
            
            // Only advance if we're significantly closer to the next step
            if (closestStep > currentStep) {
                const currentStepLocation = steps[currentStep].maneuver.location;
                const distanceToCurrent = calculateDistance(
                    userPosition.lat, userPosition.lng,
                    currentStepLocation[1], currentStepLocation[0]
                );
                
                // Only advance if we're within 30 meters of the next step
                if (distanceToCurrent < 30) {
                    console.log(`Advancing step from ${currentStep} to ${closestStep} (distance: ${distanceToCurrent}m)`);
                    return closestStep;
                }
            }
            
            return currentStep; // Stay on current step
        }

        // Update navigation display
        function updateNavigationDisplay() {
            if (!route || currentStep >= route.routes[0].legs[0].steps.length) {
                document.getElementById('nav-main-instruction').textContent = 'You have arrived!';
                document.getElementById('nav-sub-instruction').textContent = 'Destination reached';
                document.getElementById('nav-direction-icon').textContent = '‚óè';
                
                // Speak arrival message
                speakInstruction('You have arrived at your destination.');
                
                stopNavigation();
                return;
            }

            const step = route.routes[0].legs[0].steps[currentStep];
            const instruction = getBetterInstruction(step);
            const roadName = step.name || step.maneuver.name || '';
            
            // Update navigation banner
            document.getElementById('nav-main-instruction').textContent = instruction;
            document.getElementById('nav-sub-instruction').textContent = roadName;
            
            // Update direction icon
            updateDirectionIcon(step.maneuver.type);
            
            // Track spoken instructions to prevent skipping
            const instructionKey = `${currentStep}:${instruction}`;
            if (!spokenInstructions.has(instructionKey)) {
                spokenInstructions.add(instructionKey);
                lastStepSpoken = currentStep;
                
                // Speak the instruction
                speakInstruction(instruction, null, true);
                console.log(`Spoke instruction for step ${currentStep}: ${instruction}`);
            } else {
                console.log(`Already spoke instruction for step ${currentStep}, skipping`);
            }
        }

        // Update direction icon
        function updateDirectionIcon(maneuverType) {
            const iconElement = document.getElementById('nav-direction-icon');
            let icon = '‚Üí';
            
            switch(maneuverType) {
                case 'turn-right':
                    icon = '‚Üí';
                    break;
                case 'turn-left':
                    icon = '‚Üê';
                    break;
                case 'turn-slight-right':
                    icon = '‚Üó';
                    break;
                case 'turn-slight-left':
                    icon = '‚Üñ';
                    break;
                case 'turn-sharp-right':
                    icon = '‚Üò';
                    break;
                case 'turn-sharp-left':
                    icon = '‚Üô';
                    break;
                case 'uturn':
                    icon = '‚Üª';
                    break;
                case 'arrive':
                    icon = '‚óè';
                    break;
                default:
                    icon = '‚Üí';
            }
            
            iconElement.textContent = icon;
        }

        // Calculate distance between two points
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                     Math.cos(œÜ1) * Math.cos(œÜ2) *
                     Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Toggle directions panel
        function toggleDirections() {
            const panel = document.getElementById('directions-panel');
            if (panel.classList.contains('show')) {
                panel.classList.remove('show');
            } else {
                panel.classList.add('show');
            }
        }

        // Show status message
        function showStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.display = 'block';
        }

        // Hide status message
        function hideStatus() {
            const status = document.getElementById('status');
            status.style.display = 'none';
        }

        // Handle enter key in search
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            // Handle enter key in search
            document.getElementById('destination').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    getDirections();
                }
            });

            // Mobile-specific improvements
            if ('ontouchstart' in window) {
                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

                // Improve touch targets
                const touchElements = document.querySelectorAll('button, input, .direction-step');
                touchElements.forEach(element => {
                    element.style.minHeight = '44px'; // iOS minimum touch target
                });

                // Add touch feedback
                const buttons = document.querySelectorAll('button');
                buttons.forEach(button => {
                    button.addEventListener('touchstart', function() {
                        this.style.opacity = '0.7';
                    });
                    button.addEventListener('touchend', function() {
                        this.style.opacity = '1';
                    });
                });
            }

            // Prevent pull-to-refresh on mobile
            document.body.addEventListener('touchmove', function(e) {
                if (e.target.closest('#map')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Handle viewport changes
            window.addEventListener('resize', function() {
                if (map) {
                    map.invalidateSize();
                }
            });
        });
    </script>
</body>
</html> 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Speedometer</title>
    <link rel="icon" type="image/png" href="speedometer.png">
    <link rel="apple-touch-icon" href="speedometer.png">
    <!-- Make the status bar black with white text -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            height: -webkit-fill-available; /* iOS Safari */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS Safari */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            overflow: auto;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: min(90vw, 600px);
            width: 100%;
            text-align: center;
            transition: all 0.3s ease;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                border-radius: 20px;
                max-width: 95vw;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
                border-radius: 15px;
                max-width: 98vw;
            }
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: clamp(1.5em, 4vw, 2em);
        }

        @media (max-width: 768px) {
            h1 {
                margin-bottom: 20px;
            }
        }

        .speedometer-container {
            position: relative;
            width: 100%;
            max-width: min(90vw, 700px);
            height: auto;
            margin: 0 auto 30px;
        }

        @media (max-width: 768px) {
            .speedometer-container {
                max-width: 95vw;
                margin: 0 auto 20px;
            }
        }

        @media (max-width: 480px) {
            .speedometer-container {
                max-width: 98vw;
                margin: 0 auto 15px;
            }
        }

        canvas {
            display: block;
            margin: 0 auto;
            width: 100%;
            max-width: 700px;
            height: auto;
        }

        .speed-display {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .speed-value {
            font-size: clamp(2em, 8vw, 3.5em);
            font-weight: bold;
            color: #667eea;
            line-height: 1;
            margin-bottom: 5px;
            font-variant-numeric: tabular-nums;
        }

        .speed-unit {
            font-size: 1.2em;
            color: #666;
            font-weight: 500;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 500;
        }

        .status.waiting {
            background: #fff3cd;
            color: #856404;
        }

        .status.active {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Theme modes - make status text white with semi-transparent backgrounds */
        .container.theme-night:not(.simple-mode) .status.waiting,
        .container.theme-night:not(.simple-mode) .status.active,
        .container.theme-night:not(.simple-mode) .status.error {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .container.theme-classic:not(.simple-mode) .status.waiting,
        .container.theme-classic:not(.simple-mode) .status.active,
        .container.theme-classic:not(.simple-mode) .status.error {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .container.theme-blue:not(.simple-mode) .status.waiting,
        .container.theme-blue:not(.simple-mode) .status.active,
        .container.theme-blue:not(.simple-mode) .status.error {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .info {
            margin-top: 20px;
            color: #666;
            font-size: 0.9em;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #eee;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .speed-limit-sign {
            display: inline-flex;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 6px solid #dc143c;
            background: white;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: #dc143c;
            margin: 10px auto;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .speed-limit-sign.over-limit {
            background: #ffebee;
            animation: pulse 1s ease-in-out infinite;
        }

        .speed-limit-sign.flashing {
            animation: flash 0.3s ease-in-out 5;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 8px rgba(220, 20, 60, 0.3);
            }
            50% {
                box-shadow: 0 4px 16px rgba(220, 20, 60, 0.6);
            }
        }

        @keyframes flash {
            0%, 100% {
                background: white;
                border-color: #dc143c;
            }
            50% {
                background: #ff4444;
                border-color: #ff0000;
                transform: scale(1.1);
            }
        }

        .hud-speed-limit-sign {
            display: inline-flex;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 4px solid #dc143c;
            background: white;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #dc143c;
            margin: 5px auto;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .hud-speed-limit-sign.over-limit {
            background: #ffebee;
            animation: pulse 1s ease-in-out infinite;
        }

        .hud-speed-limit-sign.flashing {
            animation: flash 0.3s ease-in-out 5;
        }

        @media (max-width: 768px) {
            .speed-limit-sign {
                width: 70px;
                height: 70px;
                font-size: 1.8em;
                border-width: 5px;
            }
        }

        @media (max-width: 480px) {
            .speed-limit-sign {
                width: 60px;
                height: 60px;
                font-size: 1.5em;
                border-width: 4px;
            }
        }

        .simple-toggle,
        .hud-toggle {
            position: fixed;
            top: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 25px;
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            color: #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .simple-toggle.hidden,
        .hud-toggle.hidden,
        .theme-toggle.hidden,
        .debug-toggle.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }

        .simple-toggle {
            right: 20px;
        }

        .hud-toggle {
            right: 180px;
        }

        .theme-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 25px;
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            color: #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .theme-toggle:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .theme-menu {
            position: fixed;
            top: 70px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #667eea;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            min-width: 200px;
        }

        .theme-menu.active {
            display: block;
        }

        .theme-option {
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .theme-option:hover {
            background: #f0f0f0;
            transform: translateX(5px);
        }

        .theme-option.active {
            background: #667eea;
            color: white;
        }

        .simple-toggle:hover,
        .hud-toggle:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .simple-toggle.active,
        .hud-toggle.active {
            background: #667eea;
            color: white;
        }

        @media (max-width: 768px) {
            .hud-toggle {
                right: 20px;
                top: 70px;
            }
        }

        .container.simple-mode {
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .container.simple-mode h1 {
            display: none;
        }

        .container.simple-mode .speedometer-container {
            display: none;
        }

        .container.simple-mode .status,
        .container.simple-mode .info {
            display: none;
        }

        .container.simple-mode .stats {
            display: none;
        }

        .container.hud-flip {
            transform: scale(-1, -1); /* Flip both horizontally and vertically for HUD display */
            -webkit-transform: scale(-1, -1); /* Safari support */
        }

        /* Theme: Night (Black/White/Green) */
        body.theme-night {
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
        }

        .container.theme-night {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
        }

        /* Normal mode - white text */
        .container.theme-night:not(.simple-mode) h1,
        .container.theme-night:not(.simple-mode) .speed-value,
        .container.theme-night:not(.simple-mode) .stat-value,
        .container.theme-night:not(.simple-mode) .stat-label,
        .container.theme-night:not(.simple-mode) .speed-unit,
        .container.theme-night:not(.simple-mode) .status,
        .container.theme-night:not(.simple-mode) .info {
            color: #fff;
        }

        /* Simple mode - keep green colors */
        .container.theme-night .hud-speed {
            color: #00ff00;
            text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .container.theme-night .hud-stat-value {
            color: #00ff00;
        }

        .container.theme-night .hud-unit {
            color: rgba(0, 255, 0, 0.8);
        }

        .container.theme-night .hud-stat-label {
            color: rgba(0, 255, 0, 0.7);
        }

        .container.theme-night.simple-mode {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
        }

        /* Theme: Classic (Red/Amber) */
        body.theme-classic {
            background: linear-gradient(135deg, #1a0000 0%, #2d0000 100%);
        }

        .container.theme-classic {
            background: rgba(20, 0, 0, 0.95);
            border: 2px solid #ff4444;
        }

        /* Normal mode - white text */
        .container.theme-classic:not(.simple-mode) h1,
        .container.theme-classic:not(.simple-mode) .speed-value,
        .container.theme-classic:not(.simple-mode) .stat-value,
        .container.theme-classic:not(.simple-mode) .stat-label,
        .container.theme-classic:not(.simple-mode) .speed-unit,
        .container.theme-classic:not(.simple-mode) .status,
        .container.theme-classic:not(.simple-mode) .info {
            color: #fff;
        }

        /* Simple mode - keep amber colors */
        .container.theme-classic .hud-speed {
            color: #ffaa00;
            text-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
        }

        .container.theme-classic .hud-stat-value {
            color: #ffaa00;
        }

        .container.theme-classic .hud-unit {
            color: rgba(255, 170, 0, 0.8);
        }

        .container.theme-classic .hud-stat-label {
            color: rgba(255, 170, 0, 0.7);
        }

        .container.theme-classic.simple-mode {
            background: rgba(20, 0, 0, 0.95);
            border: 2px solid #ff4444;
        }

        /* Theme: Blue (Modern) */
        body.theme-blue {
            background: linear-gradient(135deg, #001122 0%, #003366 100%);
        }

        .container.theme-blue {
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #00aaff;
        }

        /* Normal mode - white text */
        .container.theme-blue:not(.simple-mode) h1,
        .container.theme-blue:not(.simple-mode) .speed-value,
        .container.theme-blue:not(.simple-mode) .stat-value,
        .container.theme-blue:not(.simple-mode) .stat-label,
        .container.theme-blue:not(.simple-mode) .speed-unit,
        .container.theme-blue:not(.simple-mode) .status,
        .container.theme-blue:not(.simple-mode) .info {
            color: #fff;
        }

        /* Simple mode - keep blue colors */
        .container.theme-blue .hud-speed {
            color: #00aaff;
            text-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        .container.theme-blue .hud-stat-value {
            color: #00aaff;
        }

        .container.theme-blue .hud-unit {
            color: rgba(0, 170, 255, 0.8);
        }

        .container.theme-blue .hud-stat-label {
            color: rgba(0, 170, 255, 0.7);
        }

        .container.theme-blue.simple-mode {
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #00aaff;
        }

        .hud-display {
            display: none;
            text-align: center;
            padding: 40px 20px;
        }

        .container.simple-mode .hud-display {
            display: block;
        }

        .hud-speed {
            font-size: clamp(4em, 15vw, 8em);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            line-height: 1;
            margin-bottom: 10px;
            font-variant-numeric: tabular-nums;
        }

        .hud-unit {
            font-size: clamp(1em, 4vw, 2em);
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 40px;
        }

        .hud-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin-top: 40px;
        }

        .hud-stat {
            text-align: center;
        }

        .hud-stat-label {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hud-stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            font-variant-numeric: tabular-nums;
        }

        @media (max-width: 768px) {
            .hud-speed {
                font-size: 5em;
            }

            .hud-unit {
                font-size: 1.5em;
            }

            .hud-stats {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .hud-stat-value {
                font-size: 2em;
            }
        }

        .debug-panel {
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #667eea;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            max-width: 300px;
            max-height: 70vh;
            overflow-y: auto;
            display: none;
        }

        @media (max-width: 768px) {
            .debug-panel {
                max-width: calc(100vw - 40px);
                bottom: 80px;
            }
        }

        .debug-panel.active {
            display: block;
        }

        .debug-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #ff6b6b;
            border-radius: 25px;
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            color: #ff6b6b;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .theme-menu.hidden {
            display: none !important;
        }

        .debug-toggle:hover {
            background: #ff6b6b;
            color: white;
            transform: scale(1.05);
        }

        .debug-toggle.active {
            background: #ff6b6b;
            color: white;
        }

        .debug-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .debug-button {
            padding: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .debug-button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .debug-slider {
            width: 100%;
            margin: 10px 0;
        }

        .debug-input-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .debug-input {
            flex: 1;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .debug-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle">Theme</button>
    <div class="theme-menu" id="themeMenu">
        <div class="theme-option active" data-theme="default">Default</div>
        <div class="theme-option" data-theme="night">Night (Green)</div>
        <div class="theme-option" data-theme="classic">Classic (Amber)</div>
        <div class="theme-option" data-theme="blue">Blue (Modern)</div>
    </div>
    <button class="simple-toggle" id="simpleToggle">Simple Mode</button>
    <button class="hud-toggle" id="hudToggle">HUD Mode</button>
    <button class="debug-toggle" id="debugToggle">Debug Mode</button>
    <div class="debug-panel" id="debugPanel">
        <div class="debug-label">Debug Controls</div>
        <div class="debug-controls">
            <input type="range" class="debug-slider" id="speedSlider" min="0" max="130" value="0">
            <div style="text-align: center; margin-bottom: 10px;">
                <span id="sliderValue">0</span> km/h
            </div>
            <div class="debug-button" onclick="setSpeed(0)">Stop (0 km/h)</div>
            <div class="debug-button" onclick="setSpeed(30)">City (30 km/h)</div>
            <div class="debug-button" onclick="setSpeed(50)">Urban (50 km/h)</div>
            <div class="debug-button" onclick="setSpeed(80)">Highway (80 km/h)</div>
            <div class="debug-button" onclick="setSpeed(120)">Fast (120 km/h)</div>
            <div class="debug-input-group">
                <input type="number" class="debug-input" id="customSpeed" placeholder="Speed" min="0" max="130">
                <button class="debug-button" onclick="setCustomSpeed()">Set</button>
            </div>
            <div class="debug-button" onclick="simulateAcceleration()">Simulate Acceleration</div>
            <div class="debug-button" onclick="simulateDeceleration()">Simulate Deceleration</div>
            <div class="debug-button" onclick="resetStats()">Reset Stats</div>
            <div class="debug-label" style="margin-top: 15px;">Speed Limit Debug</div>
            <div class="debug-input-group">
                <input type="number" class="debug-input" id="customSpeedLimit" placeholder="Speed Limit" min="0" max="200">
                <button class="debug-button" onclick="setCustomSpeedLimit()">Set Limit</button>
            </div>
            <div class="debug-label" style="margin-top: 10px;">Test Speed Limit by Location</div>
            <div class="debug-input-group">
                <input type="number" step="any" class="debug-input" id="testLat" placeholder="Latitude" style="width: 48%;">
                <input type="number" step="any" class="debug-input" id="testLon" placeholder="Longitude" style="width: 48%;">
            </div>
            <button class="debug-button" onclick="testSpeedLimitByLocation()">Test Location</button>
            <div class="debug-button" onclick="testSpeedLimitSound()">Test Sound</div>
            <div class="debug-button" onclick="clearSpeedLimit()">Clear Limit</div>
        </div>
    </div>
    <div class="container" id="container">
        <h1>ðŸš— Speedometer</h1>
        <div class="speedometer-container">
            <canvas id="speedometer" width="700" height="350"></canvas>
            <div class="speed-display">
                <div class="speed-value" id="speedValue">0</div>
                <div class="speed-unit">km/h</div>
            </div>
        </div>
        <div class="status waiting" id="status">Waiting for GPS signal...</div>
        <div class="info" id="info">Make sure location services are enabled</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Max Speed</div>
                <div class="stat-value" id="maxSpeed">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Avg Speed</div>
                <div class="stat-value" id="avgSpeed">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Distance</div>
                <div class="stat-value" id="distance">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Speed Limit</div>
                <div class="speed-limit-sign" id="speedLimit">--</div>
            </div>
        </div>
        <!-- HUD Mode Display -->
        <div class="hud-display">
            <div class="hud-speed" id="hudSpeedValue">0</div>
            <div class="hud-unit">km/h</div>
            <div class="hud-stats">
                <div class="hud-stat">
                    <div class="hud-stat-label">Max</div>
                    <div class="hud-stat-value" id="hudMaxSpeed">0</div>
                </div>
                <div class="hud-stat">
                    <div class="hud-stat-label">Avg</div>
                    <div class="hud-stat-value" id="hudAvgSpeed">0</div>
                </div>
                <div class="hud-stat">
                    <div class="hud-stat-label">Distance</div>
                    <div class="hud-stat-value" id="hudDistance">0</div>
                </div>
                <div class="hud-stat">
                    <div class="hud-stat-label">Limit</div>
                    <div class="hud-speed-limit-sign" id="hudSpeedLimit">--</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('speedometer');
        const ctx = canvas.getContext('2d');
        const speedValue = document.getElementById('speedValue');
        const status = document.getElementById('status');
        const info = document.getElementById('info');
        const maxSpeedEl = document.getElementById('maxSpeed');
        const avgSpeedEl = document.getElementById('avgSpeed');
        const distanceEl = document.getElementById('distance');
        const speedLimitEl = document.getElementById('speedLimit');
        const hudSpeedLimitEl = document.getElementById('hudSpeedLimit');
        const simpleToggle = document.getElementById('simpleToggle');
        const hudToggle = document.getElementById('hudToggle');
        const container = document.getElementById('container');

        let simpleMode = true; // Default to simple mode
        let hudFlipMode = false;
        let debugMode = false;
        let currentTheme = 'default';
        let currentSpeed = 0;
        let targetSpeed = 0;
        let maxSpeed = 0;
        let speedHistory = [];
        let totalDistance = 0;
        let lastPosition = null;
        let lastUpdateTime = Date.now();
        let watchId = null;
        let debugSpeed = 0;
        let simulationInterval = null;
        let gpsReadingsCount = 0; // Track number of GPS readings to filter initial spikes
        const MAX_REALISTIC_SPEED = 150; // Maximum realistic speed in km/h (filter anything above)
        const MIN_GPS_READINGS = 3; // Minimum readings before accepting high speeds
        
        // Speed limit system
        let currentSpeedLimit = null;
        let speedLimitSound = null;
        let speedLimitReturnSound = null;
        let lastSpeedLimitCheck = null;
        let isOverSpeedLimit = false;
        let wasOverSpeedLimit = false; // Track previous state
        let flashAnimationActive = false; // Track if flash animation is active
        let speedLimitDebugMode = false; // Debug mode for speed limit
        const SPEED_LIMIT_CHECK_INTERVAL = 5000; // Check every 5 seconds
        const OVERPASS_API_URL = 'https://overpass-api.de/api/interpreter';
        
        // Load speed limit sounds from folder
        try {
            speedLimitSound = new Audio('speedlimit-alert.mp3');
            speedLimitSound.volume = 0.7;
            speedLimitSound.preload = 'auto';
        } catch (error) {
            console.warn('Speed limit alert sound file not found. Please add speedlimit-alert.mp3 to the folder.');
        }
        
        try {
            speedLimitReturnSound = new Audio('speedlimit-return.mp3');
            speedLimitReturnSound.volume = 0.7;
            speedLimitReturnSound.preload = 'auto';
        } catch (error) {
            console.warn('Speed limit return sound file not found. Please add speedlimit-return.mp3 to the folder.');
        }

        // Responsive canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(700, window.innerWidth - 40);
            const aspectRatio = 700 / 350;
            canvas.width = maxWidth;
            canvas.height = maxWidth / aspectRatio;
        }

        // Initial resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Speedometer configuration - clockwise from bottom left to bottom right
        let centerX = canvas.width / 2;
        let centerY = canvas.height;
        let radius = canvas.width * 0.4; // Responsive radius based on canvas width
        // Start at bottom left (225 degrees) and go clockwise to bottom right (315 degrees)
        // For clockwise movement, we go from 315Â° (max speed) to 225Â° (0 speed) in reverse
        const startAngle = Math.PI * 1.75; // 315 degrees (bottom right) - where max speed is
        const endAngle = Math.PI * 1.25; // 225 degrees (bottom left) - where 0 speed is
        const maxSpeedDisplay = 130; // Maximum speed to display on gauge

        // Smooth animation using requestAnimationFrame
        function animate() {
            // Update dimensions in case of resize
            centerX = canvas.width / 2;
            centerY = canvas.height;
            radius = canvas.width * 0.4;
            
            // Smooth interpolation for speed display
            const smoothingFactor = 0.15;
            currentSpeed += (targetSpeed - currentSpeed) * smoothingFactor;
            
            // Calculate distance using speed-based logic: Î”d = v_m/s Ã— Î”t
            const now = Date.now();
            const timeDiff = (now - lastUpdateTime) / 1000; // seconds
            
            if (timeDiff > 0 && currentSpeed > 0) {
                // Convert speed from km/h to m/s: v_m/s = v_km/h Ã— 0.277778
                const speedMs = currentSpeed * 0.277778;
                
                // Calculate distance increment: Î”d = v_m/s Ã— Î”t
                const deltaDistance = speedMs * timeDiff;
                
                // Accumulate distance: d = d + Î”d
                totalDistance += deltaDistance;
                
                lastUpdateTime = now;
            } else if (timeDiff > 0) {
                // Update time even if speed is 0
                lastUpdateTime = now;
            }
            
            // Only draw speedometer if not in simple mode
            if (!simpleMode) {
                drawSpeedometer();
            }
            updateDisplay();
            
            requestAnimationFrame(animate);
        }

        function getThemeColors() {
            switch(currentTheme) {
                case 'night':
                    return {
                        arc: '#333',
                        activeArc: '#00ff00',
                        ticks: '#00ff00',
                        labels: '#00ff00',
                        needle: '#00ff00',
                        center: '#00ff00'
                    };
                case 'classic':
                    return {
                        arc: '#440000',
                        activeArc: '#ffaa00',
                        ticks: '#ffaa00',
                        labels: '#ffaa00',
                        needle: '#ffaa00',
                        center: '#ffaa00'
                    };
                case 'blue':
                    return {
                        arc: '#003366',
                        activeArc: '#00aaff',
                        ticks: '#00aaff',
                        labels: '#00aaff',
                        needle: '#00aaff',
                        center: '#00aaff'
                    };
                default:
                    return {
                        arc: '#444',
                        activeArc: '#000',
                        ticks: '#000',
                        labels: '#000',
                        needle: '#000',
                        center: '#000'
                    };
            }
        }

        function drawSpeedometer() {
            // Clear canvas (transparent background)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const colors = getThemeColors();

            // Draw background arc (inactive portion)
            ctx.strokeStyle = colors.arc;
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.beginPath();
            // Draw from 225Â° to 315Â° - canvas will take the shorter clockwise path
            ctx.arc(centerX, centerY, radius, endAngle, startAngle);
            ctx.stroke();

            // Calculate speed percentage
            // At 0 speed, needle at endAngle (225Â°, bottom left)
            // At max speed, needle at startAngle (315Â°, bottom right)
            // As speed increases, angle goes from endAngle to startAngle (clockwise)
            const speedPercent = Math.min(currentSpeed / maxSpeedDisplay, 1);
            const angle = endAngle + (startAngle - endAngle) * speedPercent;

            // Draw active speed arc
            ctx.strokeStyle = colors.activeArc;
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.beginPath();
            // Draw from endAngle (225Â°) to current angle - clockwise
            ctx.arc(centerX, centerY, radius, endAngle, angle);
            ctx.stroke();

            // Draw tick marks (every 10 km/h: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130)
            ctx.strokeStyle = colors.ticks;
            const totalTicks = 13; // 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130
            for (let i = 0; i <= totalTicks; i++) {
                const tickAngle = endAngle + (startAngle - endAngle) * (i / totalTicks);
                const tickLength = 20;
                const tickRadius = radius - 30;
                
                const x1 = centerX + Math.cos(tickAngle) * tickRadius;
                const y1 = centerY + Math.sin(tickAngle) * tickRadius;
                const x2 = centerX + Math.cos(tickAngle) * (radius + tickLength);
                const y2 = centerY + Math.sin(tickAngle) * (radius + tickLength);
                
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Draw speed labels (every 10 km/h)
                const speed = (i / totalTicks) * maxSpeedDisplay;
                const labelX = centerX + Math.cos(tickAngle) * (radius - 60);
                const labelY = centerY + Math.sin(tickAngle) * (radius - 60);
                ctx.fillStyle = colors.labels;
                const fontSize = Math.max(12, canvas.width / 45); // Responsive font size
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(speed), labelX, labelY);
            }

            // Draw needle
            const needleAngle = endAngle + (startAngle - endAngle) * speedPercent;
            const needleLength = radius - 40;
            const needleX = centerX + Math.cos(needleAngle) * needleLength;
            const needleY = centerY + Math.sin(needleAngle) * needleLength;

            ctx.strokeStyle = colors.needle;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(needleX, needleY);
            ctx.stroke();

            // Draw center circle
            ctx.fillStyle = colors.center;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        function updateDisplay() {
            const roundedSpeed = Math.round(currentSpeed);
            speedValue.textContent = roundedSpeed;
            
            // Update max speed
            if (targetSpeed > maxSpeed) {
                maxSpeed = targetSpeed;
            }
            maxSpeedEl.textContent = Math.round(maxSpeed);

            // Calculate average speed (all speeds in this session)
            let avg = 0;
            if (speedHistory.length > 0) {
                avg = speedHistory.reduce((a, b) => a + b, 0) / speedHistory.length;
                avgSpeedEl.textContent = Math.round(avg);
            }

            // Update distance
            const distanceKm = (totalDistance / 1000).toFixed(2);
            distanceEl.textContent = distanceKm + ' km';

            // Update HUD display if in simple mode
            if (simpleMode) {
                const hudSpeedValue = document.getElementById('hudSpeedValue');
                const hudMaxSpeed = document.getElementById('hudMaxSpeed');
                const hudAvgSpeed = document.getElementById('hudAvgSpeed');
                const hudDistance = document.getElementById('hudDistance');
                
                if (hudSpeedValue) hudSpeedValue.textContent = roundedSpeed;
                if (hudMaxSpeed) hudMaxSpeed.textContent = Math.round(maxSpeed);
                if (hudAvgSpeed) hudAvgSpeed.textContent = Math.round(avg);
                if (hudDistance) hudDistance.textContent = distanceKm;
            }
            
            // Check if over speed limit and update display
            checkSpeedLimitExceeded();
            updateSpeedLimitDisplay();
        }

        function updateSpeed(speed, isKmh = false) {
            // Convert m/s to km/h if needed (only if not already in km/h and not in debug mode)
            if (!isKmh && !debugMode && speed < 100) {
                speed = speed * 3.6; // Assuming speed is in m/s
            }
            
            // Validate speed to prevent spikes
            speed = Math.max(0, speed);
            
            // Filter out unrealistic speeds (especially on initial GPS readings)
            if (!debugMode) {
                // If speed is very high and we don't have many readings yet, cap it
                if (speed > MAX_REALISTIC_SPEED && gpsReadingsCount < MIN_GPS_READINGS) {
                    // Likely a GPS spike, set to 0 or current speed
                    speed = Math.min(speed, currentSpeed || 0);
                }
                
                // If speed jumps from 0 to very high (>80 km/h), it's likely a GPS error
                if (currentSpeed < 5 && speed > 80 && gpsReadingsCount < MIN_GPS_READINGS) {
                    speed = 0; // Ignore the spike
                }
                
                // Always cap at maximum realistic speed
                speed = Math.min(speed, MAX_REALISTIC_SPEED);
            }
            
            targetSpeed = speed;
            
            // Add to history for average calculation (keep all speeds from this session)
            speedHistory.push(targetSpeed);
            // No limit - keep all speeds for session average
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function handlePosition(position) {
            // Skip GPS updates if debug mode is active
            if (debugMode) {
                return;
            }

            const speed = position.coords.speed;
            const now = Date.now();
            const accuracy = position.coords.accuracy;
            
            // Increment GPS readings counter
            gpsReadingsCount++;
            
            // Ignore readings with very poor accuracy (>100m) on initial readings
            if (gpsReadingsCount < MIN_GPS_READINGS && accuracy > 100) {
                return; // Skip this reading
            }
            
            // Handle speed updates
            // Note: Distance is now calculated using speed-based logic in the animate loop
            if (speed !== null && speed !== undefined) {
                // GPS provides speed directly
                updateSpeed(speed);
                status.className = 'status active';
                status.textContent = 'GPS Active';
                info.textContent = `Accuracy: Â±${Math.round(accuracy)}m`;
            } else if (lastPosition) {
                // Calculate speed from position changes if GPS speed is not available
                const timeDiff = (now - lastUpdateTime) / 1000; // in seconds
                
                // Only calculate if we have a reasonable time difference (>0.5s to avoid spikes)
                if (timeDiff > 0.5) {
                    const dist = calculateDistance(
                        lastPosition.coords.latitude,
                        lastPosition.coords.longitude,
                        position.coords.latitude,
                        position.coords.longitude
                    );
                    
                    const calculatedSpeed = dist / timeDiff; // m/s
                    
                    // Only use calculated speed if it's reasonable
                    // Ignore if accuracy is poor and speed seems too high
                    if (calculatedSpeed < 50 || (accuracy < 50 && calculatedSpeed < 100)) {
                        updateSpeed(calculatedSpeed);
                        status.className = 'status active';
                        status.textContent = 'GPS Active (Calculated Speed)';
                        info.textContent = `Accuracy: Â±${Math.round(accuracy)}m`;
                    } else {
                        // Likely a GPS error, don't update speed
                        status.className = 'status active';
                        status.textContent = 'GPS Active (Filtering)';
                        info.textContent = `Accuracy: Â±${Math.round(accuracy)}m`;
                    }
                }
            } else {
                // First position reading - just store it, don't calculate speed
                status.className = 'status active';
                status.textContent = 'GPS Active (Initializing)';
                info.textContent = `Accuracy: Â±${Math.round(accuracy)}m`;
            }

            lastPosition = position;
            // Note: lastUpdateTime is updated in the animate loop for distance calculation
            
            // Check speed limit periodically
            const currentTime = Date.now();
            if (!lastSpeedLimitCheck || (currentTime - lastSpeedLimitCheck) > SPEED_LIMIT_CHECK_INTERVAL) {
                checkSpeedLimit(position.coords.latitude, position.coords.longitude);
                lastSpeedLimitCheck = currentTime;
            }
        }
        
        // Query Overpass API for speed limit
        async function checkSpeedLimit(lat, lon, skipDebugCheck = false) {
            // Skip API query if in debug mode (unless explicitly testing)
            if (speedLimitDebugMode && !skipDebugCheck) {
                return;
            }
            
            try {
                // Create a bounding box around the current location (about 100m radius)
                const bboxSize = 0.001; // ~100 meters
                const south = lat - bboxSize;
                const west = lon - bboxSize;
                const north = lat + bboxSize;
                const east = lon + bboxSize;
                
                // Overpass QL query to find ways with maxspeed tags
                const query = `[out:json][timeout:10];
(
  way["highway"]["maxspeed"](${south},${west},${north},${east});
);
out body;
>;
out skel qt;`;
                
                const response = await fetch(OVERPASS_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `data=${encodeURIComponent(query)}`
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.elements && data.elements.length > 0) {
                    // Find the closest way with a maxspeed tag
                    let closestWay = null;
                    let minDistance = Infinity;
                    
                    // First, collect all nodes
                    const nodes = {};
                    for (const element of data.elements) {
                        if (element.type === 'node') {
                            nodes[element.id] = element;
                        }
                    }
                    
                    for (const element of data.elements) {
                        if (element.type === 'way' && element.tags && element.tags.maxspeed) {
                            // Calculate distance to way using its nodes
                            if (element.nodes && element.nodes.length > 0) {
                                for (const nodeId of element.nodes) {
                                    const node = nodes[nodeId];
                                    if (node && node.lat && node.lon) {
                                        const dist = calculateDistance(lat, lon, node.lat, node.lon);
                                        if (dist < minDistance) {
                                            minDistance = dist;
                                            closestWay = element;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (closestWay && closestWay.tags.maxspeed) {
                        const maxspeed = closestWay.tags.maxspeed;
                        // Parse speed limit (handle formats like "50", "50 km/h", "50 mph", etc.)
                        const speedMatch = maxspeed.match(/(\d+)/);
                        if (speedMatch) {
                            let limit = parseInt(speedMatch[1]);
                            
                            // Convert mph to km/h if needed
                            if (maxspeed.toLowerCase().includes('mph')) {
                                limit = Math.round(limit * 1.60934);
                            }
                            
                            currentSpeedLimit = limit;
                            updateSpeedLimitDisplay();
                            checkSpeedLimitExceeded();
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching speed limit:', error);
                // Don't update display on error, keep last known limit
            }
        }
        
        // Check if current speed exceeds limit and play sound
        function checkSpeedLimitExceeded() {
            const nowOverLimit = currentSpeedLimit && currentSpeed > currentSpeedLimit;
            
            // Just went over the limit
            if (nowOverLimit && !wasOverSpeedLimit) {
                isOverSpeedLimit = true;
                wasOverSpeedLimit = true;
                triggerFlashAnimation();
                playSpeedLimitSound();
                vibrateSpeedLimitAlert();
            }
            // Just went back under the limit
            else if (!nowOverLimit && wasOverSpeedLimit) {
                isOverSpeedLimit = false;
                wasOverSpeedLimit = false;
                stopFlashAnimation();
                playSpeedLimitReturnSound();
            }
            // Still over the limit
            else if (nowOverLimit) {
                isOverSpeedLimit = true;
            }
            // Still under the limit
            else {
                isOverSpeedLimit = false;
            }
        }
        
        // Trigger flash animation (5 flashes)
        function triggerFlashAnimation() {
            if (flashAnimationActive) return; // Don't trigger if already flashing
            
            flashAnimationActive = true;
            speedLimitEl.classList.add('flashing');
            hudSpeedLimitEl.classList.add('flashing');
            
            // Remove flash class after animation completes (5 flashes * 0.3s = 1.5s)
            setTimeout(() => {
                speedLimitEl.classList.remove('flashing');
                hudSpeedLimitEl.classList.remove('flashing');
                flashAnimationActive = false;
            }, 1500);
        }
        
        // Stop flash animation
        function stopFlashAnimation() {
            speedLimitEl.classList.remove('flashing');
            hudSpeedLimitEl.classList.remove('flashing');
            flashAnimationActive = false;
        }
        
        // Play speed limit alert sound
        function playSpeedLimitSound() {
            if (speedLimitSound) {
                speedLimitSound.currentTime = 0; // Reset to start
                speedLimitSound.play().catch(err => {
                    console.error('Error playing speed limit sound:', err);
                });
            }
        }
        
        // Play sound when returning to normal speed
        function playSpeedLimitReturnSound() {
            if (speedLimitReturnSound) {
                speedLimitReturnSound.currentTime = 0; // Reset to start
                speedLimitReturnSound.play().catch(err => {
                    console.error('Error playing speed limit return sound:', err);
                });
            }
        }
        
        // Vibrate when speed limit is exceeded
        function vibrateSpeedLimitAlert() {
            if ('vibrate' in navigator) {
                // Vibrate pattern: 5 short vibrations matching the 5 flashes
                // [vibrate, pause, vibrate, pause, ...] - each flash is 300ms, so vibrate 100ms, pause 200ms
                navigator.vibrate([100, 200, 100, 200, 100, 200, 100, 200, 100]);
            }
        }
        
        // Update speed limit display
        function updateSpeedLimitDisplay() {
            if (currentSpeedLimit) {
                speedLimitEl.textContent = currentSpeedLimit;
                hudSpeedLimitEl.textContent = currentSpeedLimit;
                
                // Add over-limit class if over speed limit
                if (currentSpeed > currentSpeedLimit) {
                    speedLimitEl.classList.add('over-limit');
                    hudSpeedLimitEl.classList.add('over-limit');
                } else {
                    speedLimitEl.classList.remove('over-limit');
                    hudSpeedLimitEl.classList.remove('over-limit');
                }
            } else {
                speedLimitEl.textContent = '--';
                hudSpeedLimitEl.textContent = '--';
                speedLimitEl.classList.remove('over-limit');
                hudSpeedLimitEl.classList.remove('over-limit');
            }
        }
        
        // Debug functions for speed limit
        function setCustomSpeedLimit() {
            const input = document.getElementById('customSpeedLimit');
            const limit = parseInt(input.value);
            if (!isNaN(limit) && limit > 0) {
                currentSpeedLimit = limit;
                speedLimitDebugMode = true; // Enable debug mode
                updateSpeedLimitDisplay();
                checkSpeedLimitExceeded();
                console.log(`Speed limit set to ${limit} km/h (Debug Mode)`);
            }
        }
        
        function testSpeedLimitSound() {
            if (speedLimitSound) {
                speedLimitSound.currentTime = 0;
                speedLimitSound.play().catch(err => {
                    console.error('Error playing speed limit sound:', err);
                    alert('Sound file not found. Please add speedlimit-alert.mp3 to the speedometer folder.');
                });
            } else {
                alert('Sound file not found. Please add speedlimit-alert.mp3 to the speedometer folder.');
            }
        }
        
        function clearSpeedLimit() {
            currentSpeedLimit = null;
            speedLimitDebugMode = false;
            updateSpeedLimitDisplay();
            console.log('Speed limit cleared');
        }
        
        // Test speed limit by entering coordinates
        async function testSpeedLimitByLocation() {
            const latInput = document.getElementById('testLat');
            const lonInput = document.getElementById('testLon');
            const lat = parseFloat(latInput.value);
            const lon = parseFloat(lonInput.value);
            
            if (isNaN(lat) || isNaN(lon)) {
                alert('Please enter valid latitude and longitude coordinates');
                return;
            }
            
            if (lat < -90 || lat > 90) {
                alert('Latitude must be between -90 and 90');
                return;
            }
            
            if (lon < -180 || lon > 180) {
                alert('Longitude must be between -180 and 180');
                return;
            }
            
            console.log(`Testing speed limit at coordinates: ${lat}, ${lon}`);
            status.className = 'status active';
            status.textContent = `Testing speed limit at ${lat.toFixed(6)}, ${lon.toFixed(6)}...`;
            info.textContent = 'Querying Overpass API...';
            
            try {
                await checkSpeedLimit(lat, lon, true); // Skip debug check for manual testing
                if (currentSpeedLimit) {
                    status.className = 'status active';
                    status.textContent = `Speed limit found: ${currentSpeedLimit} km/h`;
                    info.textContent = `Location: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                    console.log(`Speed limit at ${lat}, ${lon}: ${currentSpeedLimit} km/h`);
                } else {
                    status.className = 'status waiting';
                    status.textContent = 'No speed limit found at this location';
                    info.textContent = `Location: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                    console.log(`No speed limit data found at ${lat}, ${lon}`);
                }
            } catch (error) {
                status.className = 'status error';
                status.textContent = 'Error querying speed limit';
                info.textContent = error.message;
                console.error('Error testing speed limit:', error);
            }
        }

        function handleError(error) {
            status.className = 'status error';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    status.textContent = 'Location permission denied';
                    info.textContent = 'Please enable location access in your browser settings';
                    break;
                case error.POSITION_UNAVAILABLE:
                    status.textContent = 'Location unavailable';
                    info.textContent = 'GPS signal not available';
                    break;
                case error.TIMEOUT:
                    status.textContent = 'Location request timeout';
                    info.textContent = 'Please try again';
                    break;
                default:
                    status.textContent = 'Unknown error';
                    info.textContent = 'An error occurred';
                    break;
            }
        }

        // Start geolocation tracking with high frequency updates
        if (navigator.geolocation) {
            const options = {
                enableHighAccuracy: true,
                maximumAge: 0, // Always get fresh data
                timeout: 5000
            };

            // Use watchPosition for continuous updates
            watchId = navigator.geolocation.watchPosition(
                handlePosition,
                handleError,
                options
            );
        } else {
            status.className = 'status error';
            status.textContent = 'Geolocation not supported';
            info.textContent = 'Your browser does not support geolocation';
        }

        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        const themeMenu = document.getElementById('themeMenu');
        const themeOptions = document.querySelectorAll('.theme-option');

        function setTheme(theme) {
            currentTheme = theme;
            
            // Remove all theme classes from body and container
            document.body.classList.remove('theme-night', 'theme-classic', 'theme-blue');
            container.classList.remove('theme-night', 'theme-classic', 'theme-blue');
            
            // Add new theme class
            if (theme !== 'default') {
                document.body.classList.add(`theme-${theme}`);
                container.classList.add(`theme-${theme}`);
            }
            
            // Update active theme option
            themeOptions.forEach(option => {
                if (option.dataset.theme === theme) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        themeToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            themeMenu.classList.toggle('active');
        });

        themeOptions.forEach(option => {
            option.addEventListener('click', () => {
                const theme = option.dataset.theme;
                setTheme(theme);
                themeMenu.classList.remove('active');
            });
        });

        // Close theme menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!themeMenu.contains(e.target) && !themeToggle.contains(e.target)) {
                themeMenu.classList.remove('active');
            }
        });

        // Simple mode toggle
        simpleToggle.addEventListener('click', () => {
            simpleMode = !simpleMode;
            if (simpleMode) {
                container.classList.add('simple-mode');
                simpleToggle.classList.add('active');
                simpleToggle.textContent = 'Normal Mode';
            } else {
                container.classList.remove('simple-mode');
                simpleToggle.classList.remove('active');
                simpleToggle.textContent = 'Simple Mode';
            }
        });

        // Initialize simple mode by default
        if (simpleMode) {
            container.classList.add('simple-mode');
            simpleToggle.classList.add('active');
            simpleToggle.textContent = 'Normal Mode';
        }

        // HUD flip mode toggle
        hudToggle.addEventListener('click', () => {
            hudFlipMode = !hudFlipMode;
            if (hudFlipMode) {
                container.classList.add('hud-flip');
                hudToggle.classList.add('active');
                hudToggle.textContent = 'HUD: ON';
            } else {
                container.classList.remove('hud-flip');
                hudToggle.classList.remove('active');
                hudToggle.textContent = 'HUD Mode';
            }
        });

        // Debug mode toggle
        const debugToggle = document.getElementById('debugToggle');
        const debugPanel = document.getElementById('debugPanel');
        const speedSlider = document.getElementById('speedSlider');
        const sliderValue = document.getElementById('sliderValue');

        debugToggle.addEventListener('click', () => {
            debugMode = !debugMode;
            if (debugMode) {
                debugPanel.classList.add('active');
                debugToggle.classList.add('active');
                debugToggle.textContent = 'Debug: ON';
                status.className = 'status active';
                status.textContent = 'Debug Mode Active';
                info.textContent = 'Use controls or console commands to simulate speed';
                // Set initial debug speed to current slider value
                const initialSpeed = parseInt(speedSlider.value);
                setSpeed(initialSpeed);
            } else {
                debugPanel.classList.remove('active');
                debugToggle.classList.remove('active');
                debugToggle.textContent = 'Debug Mode';
                status.className = 'status waiting';
                status.textContent = 'Waiting for GPS signal...';
                info.textContent = 'Make sure location services are enabled';
                // Stop any simulations
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
                // Reset speed to 0 when exiting debug mode
                targetSpeed = 0;
                currentSpeed = 0;
            }
        });

        // Speed slider
        speedSlider.addEventListener('input', (e) => {
            const speed = parseInt(e.target.value);
            sliderValue.textContent = speed;
            if (debugMode) {
                setSpeed(speed);
            }
        });

        // Debug functions - available in console and UI
        window.setSpeed = function(speed) {
            if (!debugMode) {
                console.log('Enable debug mode first!');
                return;
            }
            debugSpeed = Math.max(0, Math.min(130, speed));
            updateSpeed(debugSpeed, true); // Pass true to indicate speed is already in km/h
            speedSlider.value = debugSpeed;
            sliderValue.textContent = debugSpeed;
            status.className = 'status active';
            status.textContent = `Debug: ${debugSpeed} km/h`;
        };

        window.setCustomSpeed = function() {
            const input = document.getElementById('customSpeed');
            const speed = parseInt(input.value);
            if (!isNaN(speed) && speed >= 0 && speed <= 130) {
                setSpeed(speed);
                input.value = '';
            }
        };

        window.simulateAcceleration = function() {
            if (!debugMode) {
                console.log('Enable debug mode first!');
                return;
            }
            if (simulationInterval) {
                clearInterval(simulationInterval);
            }
            let simSpeed = currentSpeed;
            simulationInterval = setInterval(() => {
                simSpeed = Math.min(130, simSpeed + 2);
                setSpeed(simSpeed);
                if (simSpeed >= 130) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
            }, 100);
        };

        window.simulateDeceleration = function() {
            if (!debugMode) {
                console.log('Enable debug mode first!');
                return;
            }
            if (simulationInterval) {
                clearInterval(simulationInterval);
            }
            let simSpeed = currentSpeed;
            simulationInterval = setInterval(() => {
                simSpeed = Math.max(0, simSpeed - 2);
                setSpeed(simSpeed);
                if (simSpeed <= 0) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
            }, 100);
        };

        window.resetStats = function() {
            maxSpeed = 0;
            speedHistory = [];
            totalDistance = 0;
            maxSpeedEl.textContent = '0';
            avgSpeedEl.textContent = '0';
            distanceEl.textContent = '0.00 km';
        };

        // Console help
        console.log('%cSpeedometer Debug Tools', 'color: #667eea; font-size: 16px; font-weight: bold;');
        console.log('Available console commands:');
        console.log('  setSpeed(speed) - Set speed directly (0-130 km/h)');
        console.log('  simulateAcceleration() - Gradually increase speed');
        console.log('  simulateDeceleration() - Gradually decrease speed');
        console.log('  resetStats() - Reset max speed, average, and distance');
        console.log('Enable Debug Mode from the UI to use these functions.');

        // Start animation loop (runs at ~60fps)
        animate();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
            }
        });

        // Register Service Worker for offline support
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }

        // Auto-hide buttons after inactivity
        let inactivityTimer = null;
        const INACTIVITY_TIME = 10000; // 10 seconds
        
        // Get all buttons (they're already defined above)
        const buttons = [themeToggle, simpleToggle, hudToggle, debugToggle].filter(btn => btn !== null);

        function showButtons() {
            buttons.forEach(btn => {
                if (btn) btn.classList.remove('hidden');
            });
            if (themeMenu && themeMenu.classList.contains('active')) {
                themeMenu.classList.remove('hidden');
            }
            
            // Vibrate when buttons reappear
            if ('vibrate' in navigator) {
                navigator.vibrate(50); // Short vibration (50ms)
            }
        }

        function hideButtons() {
            buttons.forEach(btn => {
                if (btn) {
                    // Hide all buttons, including active ones
                    btn.classList.add('hidden');
                }
            });
            // Also hide theme menu if it's open
            if (themeMenu && themeMenu.classList.contains('active')) {
                themeMenu.classList.remove('active');
            }
        }

        function resetInactivityTimer() {
            showButtons();
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(hideButtons, INACTIVITY_TIME);
        }

        // Track user activity
        ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'].forEach(event => {
            document.addEventListener(event, resetInactivityTimer, true);
        });

        // Start timer on page load
        resetInactivityTimer();

        // Wake Lock - Keep screen on while using the page
        let wakeLock = null;

        async function enableWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request("screen");
                    // Re-acquire the lock if it's lost (e.g., switching tabs)
                    wakeLock.addEventListener("release", () => {
                        console.log("Wake Lock was released");
                    });
                    console.log("Wake Lock is active");
                }
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }

        // Enable wake lock when page becomes visible
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") {
                enableWakeLock();
            }
        });

        // Enable wake lock on page load
        enableWakeLock();

        // Video workaround for iOS and devices without wake lock support
        const stayAwakeVideo = document.getElementById('stayAwakeVideo');
        if (stayAwakeVideo) {
            // Play video on first user interaction
            document.addEventListener("click", () => {
                stayAwakeVideo.play().catch(err => {
                    console.log("Video play prevented:", err);
                });
            }, { once: true });

            // Keep video playing in loop
            stayAwakeVideo.addEventListener('ended', () => {
                stayAwakeVideo.play().catch(() => {});
            });

            // Replay when page becomes visible
            document.addEventListener("visibilitychange", () => {
                if (document.visibilityState === "visible") {
                    stayAwakeVideo.play().catch(() => {});
                }
            });
        }
    </script>
    
    <!-- Video workaround for iOS wake lock -->
    <video id="stayAwakeVideo" playsinline muted loop style="display:none;">
        <source src="data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAG1tZGF0AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE1MiByMjg1NCBlOWE1OTAzIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNyAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMAA=" type="video/mp4">
    </video>
</body>
</html>

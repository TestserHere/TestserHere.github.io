<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Maps - Navigation</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .controls {
            position: absolute;
            top: 60px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            border-radius: 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.3);
            padding: 16px;
            max-width: 500px;
        }

        .search-box {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            align-items: center;
        }

        .search-box input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            outline: none;
            background: #f1f3f4;
            color: #202124;
        }

        .search-box input:focus {
            background: white;
            box-shadow: 0 1px 6px rgba(32,33,36,0.28);
        }

        .search-box button {
            padding: 12px 16px;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
        }

        .search-box button:hover {
            background: #3367d6;
        }

        .location-btn {
            width: 100%;
            padding: 12px;
            background: #34a853;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 12px;
            transition: all 0.2s;
        }

        .location-btn:hover {
            background: #2d8f47;
        }

        .directions-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 20px;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        .directions-panel.show {
            display: block;
        }

        .direction-step {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background 0.3s;
        }

        .direction-step:hover {
            background: #f8f9fa;
        }

        .direction-step.active {
            background: #e3f2fd;
            border-left: 4px solid #4285f4;
        }

        .step-instruction {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .step-distance {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .step-roads {
            font-size: 11px;
            color: #888;
            font-style: italic;
        }

        .route-summary {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #4285f4;
        }

        .route-summary h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .route-summary p {
            margin: 5px 0;
            color: #666;
        }

        .navigation-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 20px;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
            transform: translateY(100%);
            transition: transform 0.3s;
            z-index: 1000;
        }

        .navigation-bar.show {
            transform: translateY(0);
        }

        .nav-instruction {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }

        .nav-distance {
            font-size: 14px;
            color: #666;
            text-align: center;
        }

        .nav-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .nav-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .nav-btn.primary {
            background: #4285f4;
            color: white;
        }

        .nav-btn.secondary {
            background: #f1f3f4;
            color: #333;
        }

        .nav-btn:hover {
            opacity: 0.8;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .voice-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .voice-toggle.active {
            background: #4285f4;
            color: white;
        }

        /* Google Maps Navigation Banner */
        .nav-banner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            color: white;
            padding: 16px 20px;
            z-index: 1001;
            display: none;
            border-bottom: 1px solid #333;
        }

        .nav-banner.show {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .nav-instruction-main {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .nav-arrow {
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #1a1a1a;
        }

        .nav-text {
            flex: 1;
        }

        .nav-street {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .nav-direction {
            font-size: 14px;
            color: #ccc;
        }

        .nav-voice-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Car Symbol */
        .car-symbol {
            position: absolute;
            z-index: 1000;
            width: 24px;
            height: 24px;
            background: #4285f4;
            border: 3px solid white;
            border-radius: 50% 50% 0 50%;
            transform: rotate(45deg);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: none;
        }

        .car-symbol::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        /* Next Turn Indicator */
        .next-turn {
            position: absolute;
            left: 20px;
            bottom: 120px;
            background: #1a1a1a;
            color: white;
            padding: 8px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 6px;
        }

        .next-turn.show {
            display: flex;
        }

        .next-turn-arrow {
            font-size: 14px;
        }

        /* Re-center Button */
        .recenter-btn {
            position: absolute;
            left: 20px;
            bottom: 80px;
            background: white;
            border: none;
            border-radius: 20px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            cursor: pointer;
            z-index: 1000;
            display: none;
        }

        .recenter-btn.show {
            display: block;
        }

        .recenter-icon {
            width: 20px;
            height: 20px;
            background: #4285f4;
            border-radius: 50%;
            position: relative;
        }

        .recenter-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid white;
        }

        /* Bottom Navigation Bar */
        .bottom-nav {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            z-index: 1000;
            display: none;
        }

        .bottom-nav.show {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .nav-time {
            font-size: 24px;
            font-weight: 500;
            color: #f57c00;
        }

        .nav-distance {
            font-size: 14px;
            color: #666;
            margin-top: 2px;
        }

        .nav-route-btn {
            width: 40px;
            height: 40px;
            background: #f1f3f4;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-exit-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 12px 20px;
            font-weight: 500;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Google Maps Navigation Banner -->
    <div class="nav-banner" id="nav-banner">
        <div class="nav-instruction-main">
            <div class="nav-arrow" id="nav-arrow">↑</div>
            <div class="nav-text">
                <div class="nav-street" id="nav-street">Ready to navigate</div>
                <div class="nav-direction" id="nav-direction">Enter destination to start</div>
            </div>
        </div>
        <button class="nav-voice-btn" onclick="toggleVoice()">
            🎤
        </button>
    </div>

    <!-- Car Symbol -->
    <div class="car-symbol" id="car-symbol"></div>

    <!-- Next Turn Indicator -->
    <div class="next-turn" id="next-turn">
        <span class="next-turn-arrow">→</span>
        <span>Then</span>
    </div>

    <!-- Re-center Button -->
    <button class="recenter-btn" id="recenter-btn" onclick="recenterMap()">
        <div class="recenter-icon"></div>
    </button>

    <!-- Search Controls -->
    <div class="controls" id="controls">
        <div class="search-box">
            <input type="text" id="destination" placeholder="Search for a place or address">
            <button onclick="getDirections()">Directions</button>
        </div>
        <button class="location-btn" onclick="getCurrentLocation()">
            📍 Use my location
        </button>
        <div id="location-info">
            <p><strong>📍 Current Location:</strong></p>
            <p id="current-address">Getting your location...</p>
        </div>
    </div>

    <div class="directions-panel" id="directions-panel">
        <h3>Directions</h3>
        <div id="directions-list"></div>
    </div>

    <!-- Bottom Navigation Bar -->
    <div class="bottom-nav" id="bottom-nav">
        <div>
            <div class="nav-time" id="nav-time">--</div>
            <div class="nav-distance" id="nav-distance">--</div>
        </div>
        <button class="nav-route-btn" onclick="showDirections()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="#666">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
        </button>
        <button class="nav-exit-btn" onclick="stopNavigation()">Exit</button>
    </div>

    <div class="status-indicator" id="status-indicator">
        <span class="loading"></span>
        <span id="status-text">Loading...</span>
    </div>

    <button class="voice-toggle" id="voice-toggle" onclick="toggleVoice()">
        🔊
    </button>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let currentPosition;
        let destination;
        let route;
        let currentStep = 0;
        let navigationActive = false;
        let voiceEnabled = false;
        let watchId;
        let speechSynthesis = window.speechSynthesis;
        let currentMarker;
        let destinationMarker;
        let routeLine;
        let carSymbol;
        let locationPermissionGranted = false;
        let autoLocationUpdate = false;

        // Initialize the map
        function initMap() {
            // Create map using OpenStreetMap (free, no API key needed)
            map = L.map('map').setView([40.7128, -74.0060], 13); // New York City default

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Get current location on load
            getCurrentLocation();
        }

        // Get current location with high precision and persistent tracking
        function getCurrentLocation() {
            showStatus('Getting precise location...');
            
            if (navigator.geolocation) {
                // Try multiple location methods for maximum accuracy
                let locationAttempts = 0;
                const maxAttempts = 3;
                
                function tryGetLocation() {
                    locationAttempts++;
                    
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const accuracy = position.coords.accuracy;
                            console.log(`Location accuracy: ${accuracy}m`);
                            
                            // If accuracy is poor, try again
                            if (accuracy > 50 && locationAttempts < maxAttempts) {
                                showStatus(`Improving accuracy... (${locationAttempts}/${maxAttempts})`);
                                setTimeout(tryGetLocation, 2000);
                                return;
                            }
                            
                            currentPosition = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            
                            // Set location permission as granted
                            locationPermissionGranted = true;
                            
                            // Update map view
                            if (!navigationActive) {
                                map.setView([currentPosition.lat, currentPosition.lng], 16);
                            }
                            
                            // Clear existing markers
                            if (window.currentMarker) {
                                map.removeLayer(window.currentMarker);
                            }
                            if (window.accuracyCircle) {
                                map.removeLayer(window.accuracyCircle);
                            }
                            
                            // Add current location marker with accuracy circle
                            window.currentMarker = L.marker([currentPosition.lat, currentPosition.lng], {
                                icon: L.divIcon({
                                    className: 'current-location-marker',
                                    html: '<div style="background: #4285f4; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                })
                            }).addTo(map);

                            // Add accuracy circle
                            window.accuracyCircle = L.circle([currentPosition.lat, currentPosition.lng], {
                                radius: accuracy,
                                color: accuracy <= 10 ? '#34a853' : accuracy <= 50 ? '#fbbc04' : '#ea4335',
                                fillColor: accuracy <= 10 ? '#34a853' : accuracy <= 50 ? '#fbbc04' : '#ea4335',
                                fillOpacity: 0.2,
                                weight: 2
                            }).addTo(map);

                            // Update location info
                            updateLocationInfo(currentPosition, accuracy);
                            
                            // Get address for current location
                            getAddressFromCoords(currentPosition);
                            
                            // Start auto location updates if permission granted
                            if (locationPermissionGranted && !autoLocationUpdate) {
                                startAutoLocationUpdate();
                            }
                            
                            hideStatus();
                        },
                        (error) => {
                            console.error('Location error:', error);
                            if (locationAttempts < maxAttempts) {
                                showStatus(`Retrying location... (${locationAttempts}/${maxAttempts})`);
                                setTimeout(tryGetLocation, 1000);
                            } else {
                                hideStatus();
                                alert('Unable to get precise location. Please check your location settings and try again.');
                            }
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 15000,
                            maximumAge: 0
                        }
                    );
                }
                
                tryGetLocation();
            } else {
                hideStatus();
                alert('Geolocation is not supported by this browser.');
            }
        }

        // Start automatic location updates
        function startAutoLocationUpdate() {
            if (autoLocationUpdate) return;
            
            autoLocationUpdate = true;
            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    if (locationPermissionGranted) {
                        updateCurrentLocation(position);
                    }
                },
                (error) => {
                    console.error('Auto location update error:', error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 5000
                }
            );
        }

        // Update current location (for auto updates)
        function updateCurrentLocation(position) {
            currentPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            
            // Update marker position
            if (window.currentMarker) {
                window.currentMarker.setLatLng([currentPosition.lat, currentPosition.lng]);
            }
            
            // Update accuracy circle
            if (window.accuracyCircle) {
                window.accuracyCircle.setLatLng([currentPosition.lat, currentPosition.lng]);
                window.accuracyCircle.setRadius(position.coords.accuracy);
            }
            
            // Update car symbol if in navigation
            if (navigationActive && carSymbol) {
                updateCarSymbol(currentPosition);
            }
            
            // Update navigation if active
            if (navigationActive) {
                updateNavigation(position);
            }
        }

        // Update location information display
        function updateLocationInfo(coords, accuracy) {
            const accuracyText = accuracy <= 10 ? 'High' : accuracy <= 50 ? 'Medium' : 'Low';
            const accuracyColor = accuracy <= 10 ? '#34a853' : accuracy <= 50 ? '#fbbc04' : '#ea4335';
            
            document.getElementById('current-address').innerHTML = `
                <span style="color: ${accuracyColor}; font-weight: bold;">${accuracyText} Accuracy</span> 
                (${Math.round(accuracy)}m) - ${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}
            `;
        }

        // Get address from coordinates with better error handling
        function getAddressFromCoords(coords) {
            // Use Nominatim (free geocoding service)
            fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${coords.lat}&lon=${coords.lng}&zoom=18&addressdetails=1`, {
                timeout: 5000
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.display_name) {
                        const currentText = document.getElementById('current-address').innerHTML;
                        const accuracyPart = currentText.split(' - ')[0];
                        document.getElementById('current-address').innerHTML = 
                            `${accuracyPart} - ${data.display_name}`;
                    }
                })
                .catch(error => {
                    console.error('Error getting address:', error);
                    // Fallback: show coordinates if address lookup fails
                    const currentText = document.getElementById('current-address').innerHTML;
                    const accuracyPart = currentText.split(' - ')[0];
                    document.getElementById('current-address').innerHTML = 
                        `${accuracyPart} - ${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`;
                });
        }

        // Get directions using Google Maps-inspired approach
        function getDirections() {
            const destinationInput = document.getElementById('destination').value.trim();
            if (!destinationInput) {
                showError('Please enter a destination');
                return;
            }

            if (!currentPosition) {
                showError('Please get your current location first');
                return;
            }

            showStatus('Finding destination...');

            // Try multiple geocoding strategies like Google Maps
            geocodeWithFallback(destinationInput);
        }

        // Google Maps-style geocoding with multiple fallbacks and better error handling
        function geocodeWithFallback(address) {
            // Strategy 1: Direct search
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`, {
                timeout: 8000
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.length > 0) {
                        const rawDest = {
                            lat: parseFloat(data[0].lat),
                            lng: parseFloat(data[0].lon)
                        };
                        snapToRoadAndRoute(rawDest, address);
                    } else {
                        // Strategy 2: Add "Melbourne" if not found
                        const melbourneAddress = address.includes('Melbourne') ? address : `${address}, Melbourne`;
                        return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(melbourneAddress)}&limit=1&addressdetails=1`, {
                            timeout: 8000
                        });
                    }
                })
                .then(response => {
                    if (response) {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.json();
                    }
                    return null;
                })
                .then(data => {
                    if (data && data.length > 0) {
                        const rawDest = {
                            lat: parseFloat(data[0].lat),
                            lng: parseFloat(data[0].lon)
                        };
                        snapToRoadAndRoute(rawDest, address);
                    } else {
                        // Strategy 3: Try with "Australia"
                        const australiaAddress = `${address}, Australia`;
                        return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(australiaAddress)}&limit=1&addressdetails=1`, {
                            timeout: 8000
                        });
                    }
                })
                .then(response => {
                    if (response) {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.json();
                    }
                    return null;
                })
                .then(data => {
                    if (data && data.length > 0) {
                        const rawDest = {
                            lat: parseFloat(data[0].lat),
                            lng: parseFloat(data[0].lon)
                        };
                        snapToRoadAndRoute(rawDest, address);
                    } else {
                        // Strategy 4: Try alternative geocoding service
                        return fetch(`https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(address)}&key=YOUR_API_KEY&limit=1`, {
                            timeout: 8000
                        });
                    }
                })
                .then(response => {
                    if (response) {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        return response.json();
                    }
                    return null;
                })
                .then(data => {
                    if (data && data.results && data.results.length > 0) {
                        const result = data.results[0];
                        const rawDest = {
                            lat: result.geometry.lat,
                            lng: result.geometry.lng
                        };
                        snapToRoadAndRoute(rawDest, address);
                    } else {
                        showError(`Could not find "${address}". Try a more specific address or check your internet connection.`);
                    }
                })
                .catch(error => {
                    console.error('Geocoding error:', error);
                    if (error.message.includes('timeout') || error.message.includes('Failed to fetch')) {
                        showError('Network timeout. Please check your internet connection and try again.');
                    } else {
                        showError('Error finding destination. Please try again.');
                    }
                });
        }

        // Snap to road and calculate route with better error handling
        function snapToRoadAndRoute(rawDest, originalAddress) {
            showStatus('Calculating route...');
            
            // Try to snap to nearest road with timeout
            fetch(`https://router.project-osrm.org/nearest/v1/driving/${rawDest.lng},${rawDest.lat}`, {
                timeout: 5000
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(nearestData => {
                    let finalDest;
                    if (nearestData.code === 'Ok' && nearestData.waypoints.length > 0) {
                        const snapped = nearestData.waypoints[0].location;
                        finalDest = { lat: snapped[1], lng: snapped[0] };
                    } else {
                        finalDest = rawDest;
                    }
                    
                    destination = finalDest;
                    calculateRoute();
                })
                .catch(error => {
                    console.error('Road snapping error:', error);
                    // Continue with original coordinates if road snapping fails
                    destination = rawDest;
                    calculateRoute();
                });
        }

        // Calculate route with better error handling and fallbacks
        function calculateRoute() {
            const url = `https://router.project-osrm.org/route/v1/driving/${currentPosition.lng},${currentPosition.lat};${destination.lng},${destination.lat}?overview=full&steps=true&annotations=true`;
            
            fetch(url, { timeout: 15000 })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                        route = data;
                        displayRoute(data);
                        displayDirections(data);
                        hideStatus();
                        showSuccess('Route found! Click "Start Navigation" to begin.');
                        
                        // Show start navigation button
                        const startBtn = document.createElement('button');
                        startBtn.className = 'location-btn';
                        startBtn.style.marginTop = '10px';
                        startBtn.textContent = '🚗 Start Navigation';
                        startBtn.onclick = startNavigation;
                        document.getElementById('controls').appendChild(startBtn);
                    } else {
                        throw new Error(data.message || 'No route available');
                    }
                })
                .catch(error => {
                    console.error('Routing error:', error);
                    if (error.message.includes('timeout') || error.message.includes('Failed to fetch')) {
                        showError('Network timeout. Please check your internet connection and try again.');
                    } else {
                        showError(`Could not calculate route: ${error.message}. Try a different destination.`);
                    }
                });
        }

        // Display route on map with proper OSRM geometry handling
        function displayRoute(data) {
            try {
                // Clear existing route
                if (routeLine) {
                    map.removeLayer(routeLine);
                }
                if (destinationMarker) {
                    map.removeLayer(destinationMarker);
                }

                // Add destination marker
                destinationMarker = L.marker([destination.lat, destination.lng], {
                    icon: L.divIcon({
                        className: 'destination-marker',
                        html: '<div style="background: #dc3545; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);

                // Always use step coordinates for reliable route display
                const coordinates = createRouteFromSteps(data.routes[0].legs[0].steps);
                
                console.log('Route coordinates:', coordinates);

                // Create route line
                if (coordinates && coordinates.length > 1) {
                    routeLine = L.polyline(coordinates, {
                        color: '#4285f4',
                        weight: 6,
                        opacity: 0.8
                    }).addTo(map);

                    // Fit map to route
                    map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
                } else {
                    // Fallback: simple line between start and end
                    const fallbackCoordinates = [
                        [currentPosition.lat, currentPosition.lng],
                        [destination.lat, destination.lng]
                    ];
                    routeLine = L.polyline(fallbackCoordinates, {
                        color: '#4285f4',
                        weight: 6,
                        opacity: 0.8
                    }).addTo(map);
                    map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
                }
            } catch (error) {
                console.error('Error displaying route:', error);
                // Fallback: just show markers
                if (destinationMarker) {
                    map.fitBounds([
                        [currentPosition.lat, currentPosition.lng],
                        [destination.lat, destination.lng]
                    ], { padding: [20, 20] });
                }
            }
        }

        // Create route from step coordinates (reliable method)
        function createRouteFromSteps(steps) {
            const coordinates = [];
            
            // Add starting point
            if (currentPosition) {
                coordinates.push([currentPosition.lat, currentPosition.lng]);
            }
            
            // Add step coordinates
            steps.forEach(step => {
                if (step.maneuver && step.maneuver.location) {
                    const location = step.maneuver.location;
                    // OSRM uses [lng, lat] format, convert to [lat, lng] for Leaflet
                    coordinates.push([location[1], location[0]]);
                }
            });
            
            // Add destination
            if (destination) {
                coordinates.push([destination.lat, destination.lng]);
            }
            
            // Remove duplicate coordinates
            const uniqueCoordinates = [];
            coordinates.forEach(coord => {
                const exists = uniqueCoordinates.some(existing => 
                    Math.abs(existing[0] - coord[0]) < 0.0001 && 
                    Math.abs(existing[1] - coord[1]) < 0.0001
                );
                if (!exists) {
                    uniqueCoordinates.push(coord);
                }
            });
            
            console.log('Created route with', uniqueCoordinates.length, 'points');
            return uniqueCoordinates;
        }

        // Decode polyline (Google's polyline algorithm)
        function decodePolyline(encoded) {
            const poly = [];
            let index = 0, len = encoded.length;
            let lat = 0, lng = 0;

            while (index < len) {
                let shift = 0, result = 0;

                do {
                    let b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (result >= 0x20);

                let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lat += dlat;

                shift = 0;
                result = 0;

                do {
                    let b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (result >= 0x20);

                let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lng += dlng;

                poly.push([lat / 1E5, lng / 1E5]);
            }

            return poly;
        }

        // Display directions with proper step information
        function displayDirections(data) {
            const directionsPanel = document.getElementById('directions-panel');
            const directionsList = document.getElementById('directions-list');
            
            directionsPanel.classList.add('show');
            directionsList.innerHTML = '';

            const route = data.routes[0];
            const leg = route.legs[0];
            const steps = leg.steps;

            // Add route summary
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'route-summary';
            summaryDiv.innerHTML = `
                <h4>Route Summary</h4>
                <p><strong>Total Distance:</strong> ${(leg.distance / 1000).toFixed(1)} km</p>
                <p><strong>Estimated Time:</strong> ${Math.round(leg.duration / 60)} minutes</p>
            `;
            directionsList.appendChild(summaryDiv);

            steps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'direction-step';
                stepDiv.onclick = () => highlightStep(index, step);
                
                // Get step information
                const instruction = step.maneuver.instruction || 'Continue';
                const distance = step.distance || 0;
                const duration = step.duration || 0;
                
                // Get road names if available
                const currentRoad = step.name || step.maneuver.name || 'Road';
                const nextRoad = step.maneuver.after || '';
                
                // Create better instruction text
                let instructionText = instruction;
                if (currentRoad && currentRoad !== 'Road') {
                    instructionText += ` on ${currentRoad}`;
                }
                if (nextRoad && nextRoad !== currentRoad) {
                    instructionText += ` onto ${nextRoad}`;
                }
                
                stepDiv.innerHTML = `
                    <div class="step-instruction">${instructionText}</div>
                    <div class="step-distance">${distance.toFixed(0)}m • ${Math.round(duration)}s</div>
                    <div class="step-roads">
                        <small>${currentRoad}${nextRoad && nextRoad !== currentRoad ? ` → ${nextRoad}` : ''}</small>
                    </div>
                `;
                
                directionsList.appendChild(stepDiv);
            });
        }

        // Highlight step
        function highlightStep(index, step) {
            const steps = document.querySelectorAll('.direction-step');
            steps.forEach(step => step.classList.remove('active'));
            steps[index].classList.add('active');
            
            // Center map on step
            const location = step.maneuver.location;
            map.setView([location[1], location[0]], 16);
        }

        // Show navigation bar
        function showNavigationBar() {
            document.getElementById('navigation-bar').classList.add('show');
        }

        // Start navigation
        function startNavigation() {
            if (!route) return;
            
            navigationActive = true;
            currentStep = 0;
            
            // Show navigation UI
            document.getElementById('nav-banner').classList.add('show');
            document.getElementById('bottom-nav').classList.add('show');
            document.getElementById('recenter-btn').classList.add('show');
            document.getElementById('next-turn').classList.add('show');
            document.getElementById('controls').style.display = 'none';
            
            // Create car symbol
            createCarSymbol();
            
            // Update navigation display
            updateNavigationDisplay();
            
            // Start voice if enabled
            if (voiceEnabled) {
                speakInstruction('Navigation started');
            }
        }

        // Stop navigation
        function stopNavigation() {
            navigationActive = false;
            
            // Hide navigation UI
            document.getElementById('nav-banner').classList.remove('show');
            document.getElementById('bottom-nav').classList.remove('show');
            document.getElementById('recenter-btn').classList.remove('show');
            document.getElementById('next-turn').classList.remove('show');
            document.getElementById('controls').style.display = 'block';
            
            // Remove car symbol
            if (carSymbol) {
                carSymbol.style.display = 'none';
            }
            
            // Show success message
            showSuccess('Navigation ended');
        }

        // Create car symbol
        function createCarSymbol() {
            carSymbol = document.getElementById('car-symbol');
            carSymbol.style.display = 'block';
            updateCarSymbol(currentPosition);
        }

        // Update car symbol position
        function updateCarSymbol(position) {
            if (!carSymbol || !position) return;
            
            const point = map.latLngToLayerPoint([position.lat, position.lng]);
            carSymbol.style.left = (point.x - 12) + 'px';
            carSymbol.style.top = (point.y - 12) + 'px';
        }

        // Re-center map
        function recenterMap() {
            if (currentPosition) {
                map.setView([currentPosition.lat, currentPosition.lng], 16);
            }
        }

        // Show directions panel
        function showDirections() {
            const directionsPanel = document.getElementById('directions-panel');
            if (directionsPanel.classList.contains('show')) {
                directionsPanel.classList.remove('show');
            } else {
                directionsPanel.classList.add('show');
            }
        }

        // Update navigation
        function updateNavigation(position) {
            const userLocation = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };

            // Update current position marker
            if (currentMarker) {
                currentMarker.setLatLng([userLocation.lat, userLocation.lng]);
            }

            const steps = route.routes[0].legs[0].steps;
            
            // Find current step based on proximity
            let closestStep = 0;
            let minDistance = Infinity;
            
            steps.forEach((step, index) => {
                const stepLocation = step.maneuver.location;
                const distance = calculateDistance(
                    userLocation.lat, userLocation.lng,
                    stepLocation[1], stepLocation[0]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestStep = index;
                }
            });

            // Check if we're close to the current step
            const currentStepLocation = steps[currentStep].maneuver.location;
            const distanceToStep = calculateDistance(
                userLocation.lat, userLocation.lng,
                currentStepLocation[1], currentStepLocation[0]
            );

            // If we're within 50 meters of the next step, advance
            if (distanceToStep < 50 && currentStep < steps.length - 1) {
                currentStep++;
                updateNavigationDisplay();
                
                if (voiceEnabled) {
                    speakInstruction(steps[currentStep].maneuver.instruction);
                }
            }

            // Update distance to next turn
            const nextStep = steps[currentStep];
            const distanceToNext = calculateDistance(
                userLocation.lat, userLocation.lng,
                nextStep.maneuver.location[1], nextStep.maneuver.location[0]
            );

            document.getElementById('nav-distance').textContent = 
                `${Math.round(distanceToNext)}m to next turn`;
        }

        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Update navigation display
        function updateNavigationDisplay() {
            if (!route || currentStep >= route.routes[0].legs[0].steps.length) {
                document.getElementById('nav-street').textContent = 'You have arrived!';
                document.getElementById('nav-direction').textContent = 'Destination reached';
                document.getElementById('nav-arrow').textContent = '✓';
                stopNavigation();
                return;
            }

            const step = route.routes[0].legs[0].steps[currentStep];
            const leg = route.routes[0].legs[0];
            
            // Update navigation banner
            document.getElementById('nav-street').textContent = step.name || 'Continue';
            document.getElementById('nav-direction').textContent = step.maneuver.instruction || 'Continue';
            
            // Update arrow direction
            const arrow = document.getElementById('nav-arrow');
            const instruction = step.maneuver.instruction || '';
            if (instruction.includes('right')) {
                arrow.textContent = '→';
            } else if (instruction.includes('left')) {
                arrow.textContent = '←';
            } else if (instruction.includes('straight')) {
                arrow.textContent = '↑';
            } else {
                arrow.textContent = '→';
            }
            
            // Update bottom navigation
            const remainingDistance = leg.distance - (step.distance || 0);
            const remainingTime = leg.duration - (step.duration || 0);
            
            document.getElementById('nav-time').textContent = `${Math.round(remainingTime / 60)} min`;
            document.getElementById('nav-distance').textContent = `${(remainingDistance / 1000).toFixed(1)} km`;
            
            // Update next turn indicator
            if (currentStep < route.routes[0].legs[0].steps.length - 1) {
                const nextStep = route.routes[0].legs[0].steps[currentStep + 1];
                const nextArrow = document.getElementById('next-turn');
                nextArrow.innerHTML = `<span class="next-turn-arrow">→</span><span>Then ${nextStep.maneuver.instruction}</span>`;
            }
        }

        // Voice guidance
        function toggleVoice() {
            voiceEnabled = !voiceEnabled;
            const button = document.getElementById('voice-toggle');
            
            if (voiceEnabled) {
                button.classList.add('active');
                button.textContent = '🔊';
            } else {
                button.classList.remove('active');
                button.textContent = '🔇';
            }
        }

        // Speak instruction
        function speakInstruction(instruction) {
            if (speechSynthesis && voiceEnabled) {
                const utterance = new SpeechSynthesisUtterance(instruction);
                utterance.rate = 0.9;
                utterance.pitch = 1.1;
                speechSynthesis.speak(utterance);
            }
        }

        // Google Maps-style status and error handling
        function showStatus(message) {
            document.getElementById('status-text').textContent = message;
            document.getElementById('status-indicator').style.display = 'block';
        }

        function hideStatus() {
            document.getElementById('status-indicator').style.display = 'none';
        }

        function showError(message) {
            hideStatus();
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                left: 20px;
                right: 20px;
                background: #f8d7da;
                color: #721c24;
                padding: 15px;
                border-radius: 12px;
                border: 1px solid #f5c6cb;
                z-index: 10000;
                font-size: 14px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            `;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function showSuccess(message) {
            hideStatus();
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = message;
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                left: 20px;
                right: 20px;
                background: #d4edda;
                color: #155724;
                padding: 15px;
                border-radius: 12px;
                border: 1px solid #c3e6cb;
                z-index: 10000;
                font-size: 14px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            `;
            document.body.appendChild(successDiv);
            setTimeout(() => successDiv.remove(), 3000);
        }

        // Handle enter key in search
        document.getElementById('destination').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                getDirections();
            }
        });

        // Initialize map when page loads
        window.onload = function() {
            initMap();
        };
    </script>
</body>
</html>


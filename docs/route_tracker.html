<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 1000;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .tab {
            flex: 1;
            padding: 18px 24px;
            text-align: center;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .tab::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transform: scaleX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tab.active {
            color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .tab.active::before {
            transform: scaleX(1);
        }

        .tab:hover {
            background: rgba(102, 126, 234, 0.08);
            color: #667eea;
        }

        .tab-content {
            flex: 1;
            display: none;
            position: relative;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        #map {
            flex: 1;
            width: 100%;
        }

        #viewMap {
            flex: 1;
            width: 100%;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            padding: 24px;
            max-width: 420px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 16px;
            text-align: center;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: white;
            margin-bottom: 6px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .button-group {
            display: flex;
            gap: 12px;
        }

        .btn {
            flex: 1;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: linear-gradient(135deg, #ccc 0%, #999 100%);
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(235, 51, 73, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 14px 18px;
            border-radius: 12px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .status-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ccc;
            animation: pulse 2s infinite;
            box-shadow: 0 0 0 0 rgba(204, 204, 204, 0.7);
        }

        .status-dot.tracking {
            background: #38ef7d;
            box-shadow: 0 0 0 0 rgba(56, 239, 125, 0.7);
            animation: pulse-tracking 2s infinite;
        }

        .status-dot.stopped {
            background: #eb3349;
            animation: none;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(204, 204, 204, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(204, 204, 204, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(204, 204, 204, 0);
            }
        }

        @keyframes pulse-tracking {
            0% {
                box-shadow: 0 0 0 0 rgba(56, 239, 125, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(56, 239, 125, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(56, 239, 125, 0);
            }
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .file-input {
            width: 100%;
            padding: 20px;
            border: 2px dashed rgba(102, 126, 234, 0.3);
            border-radius: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
        }

        .file-input:hover {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .file-input input {
            display: none;
        }

        .route-info {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .route-info h3 {
            margin-bottom: 16px;
            color: #333;
            font-size: 18px;
            font-weight: 700;
        }

        .route-info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .route-info-item:last-child {
            border-bottom: none;
        }

        .route-info-label {
            color: #666;
            font-size: 14px;
            font-weight: 500;
        }

        .route-info-value {
            color: #667eea;
            font-weight: 700;
            font-size: 15px;
        }

        .empty-state {
            text-align: center;
            padding: 50px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        .view-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            padding: 24px;
            max-width: 380px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            border-radius: 20px;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102, 126, 234, 0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('track')">Track Route</button>
            <button class="tab" onclick="switchTab('view')">View Route</button>
        </div>

        <!-- Track Route Tab -->
        <div id="trackTab" class="tab-content active">
            <div id="map"></div>
            <div class="controls">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                </div>
                <div class="status-indicator">
                    <div class="status-dot stopped" id="statusDot"></div>
                    <span id="statusText">Ready to track</span>
                </div>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="distance">0.00</div>
                        <div class="stat-label">Kilometers</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="time">00:00</div>
                        <div class="stat-label">Time</div>
                    </div>
                </div>
                <div class="button-group">
                    <button class="btn btn-primary" id="startBtn" onclick="startTracking()">
                        <i class="fas fa-play"></i> Start
                    </button>
                    <button class="btn btn-danger" id="stopBtn" onclick="stopTracking()" disabled>
                        <i class="fas fa-stop"></i> Stop
                    </button>
                </div>
                <button class="btn btn-success" id="downloadBtn" onclick="downloadRoute()" disabled style="margin-top: 12px; width: 100%;">
                    <i class="fas fa-download"></i> Download Route
                </button>
            </div>
        </div>

        <!-- View Route Tab -->
        <div id="viewTab" class="tab-content">
            <div id="viewMap"></div>
            <div class="view-controls">
                <div class="file-input-wrapper">
                    <label class="file-input" for="routeFile">
                        <div><i class="fas fa-folder-open"></i> Click to load route file</div>
                        <input type="file" id="routeFile" accept=".json" onchange="loadRouteFile(event)">
                    </label>
                </div>
                <div class="loading-overlay" id="viewLoadingOverlay">
                    <div class="spinner"></div>
                </div>
                <div id="routeInfo" style="display: none;">
                    <div class="route-info">
                        <h3>Route Information</h3>
                        <div class="route-info-item">
                            <span class="route-info-label">Distance:</span>
                            <span class="route-info-value" id="viewDistance">-</span>
                        </div>
                        <div class="route-info-item">
                            <span class="route-info-label">Duration:</span>
                            <span class="route-info-value" id="viewTime">-</span>
                        </div>
                        <div class="route-info-item">
                            <span class="route-info-label">Points:</span>
                            <span class="route-info-value" id="viewPoints">-</span>
                        </div>
                        <div class="route-info-item">
                            <span class="route-info-label">Date:</span>
                            <span class="route-info-value" id="viewDate">-</span>
                        </div>
                    </div>
                </div>
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon"><i class="fas fa-route"></i></div>
                    <p>Load a route file to view your tracked route</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let map;
        let viewMap;
        let isTracking = false;
        let watchId = null;
        let routePoints = [];
        let snappedRoutePoints = [];
        let startTime = null;
        let timerInterval = null;
        let routePolyline = null;
        let currentMarker = null;
        let viewRoutePolyline = null;
        let startMarker = null;
        let endMarker = null;
        let snapToRoads = true;

        // Initialize tracking map
        function initTrackingMap() {
            map = L.map('map').setView([0, 0], 13);
            // Using OSM Bright from OpenMapTiles
            var OSM_Bright = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                minZoom: 0,
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>',
                tileSize: 256,
                zoomOffset: 0
            });
            OSM_Bright.addTo(map);

            // Get initial location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        map.setView([lat, lng], 15);
                    },
                    (error) => {
                        console.error('Error getting location:', error);
                    }
                );
            }
        }

        // Initialize view map
        function initViewMap() {
            viewMap = L.map('viewMap').setView([0, 0], 13);
            // Using OSM Bright from OpenMapTiles
            var OSM_Bright = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                minZoom: 0,
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>',
                tileSize: 256,
                zoomOffset: 0
            });
            OSM_Bright.addTo(viewMap);
        }

        // Switch between tabs
        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            if (tab === 'track') {
                document.getElementById('trackTab').classList.add('active');
            } else {
                document.getElementById('viewTab').classList.add('active');
                // Initialize view map if not already initialized
                if (!viewMap) {
                    setTimeout(() => {
                        initViewMap();
                    }, 100);
                }
            }
        }

        // Start tracking
        function startTracking() {
            if (!navigator.geolocation) {
                alert('Geolocation is not supported by your browser.');
                return;
            }

            isTracking = true;
            routePoints = [];
            snappedRoutePoints = [];
            startTime = Date.now();

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('statusDot').classList.remove('stopped');
            document.getElementById('statusDot').classList.add('tracking');
            document.getElementById('statusText').textContent = 'Tracking...';

            // Reset stats
            document.getElementById('distance').textContent = '0.00';
            document.getElementById('time').textContent = '00:00';

            // Clear previous route
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            if (currentMarker) {
                map.removeLayer(currentMarker);
                currentMarker = null;
            }
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }

            // Start timer
            startTimer();

            // Start watching position
            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    const timestamp = Date.now();

                    // Add point to route
                    routePoints.push({
                        lat: lat,
                        lng: lng,
                        accuracy: accuracy,
                        timestamp: timestamp
                    });

                    // Update map
                    updateTrackingMap(lat, lng);

                    // Update distance
                    updateDistance();
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    alert('Error tracking location: ' + error.message);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 1000
                }
            );
        }

        // Stop tracking
        async function stopTracking() {
            isTracking = false;

            // Stop watching position
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }

            // Stop timer
            stopTimer();

            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('statusDot').classList.remove('tracking');
            document.getElementById('statusDot').classList.add('stopped');
            document.getElementById('statusText').textContent = 'Snapping to roads...';

            if (routePoints.length > 0) {
                // Show loading overlay
                document.getElementById('loadingOverlay').classList.add('active');

                // Snap route to roads
                if (snapToRoads && routePoints.length > 1) {
                    try {
                        await snapRouteToRoads();
                    } catch (error) {
                        console.error('Error snapping to roads:', error);
                        snappedRoutePoints = routePoints; // Use original points if snapping fails
                    }
                } else {
                    snappedRoutePoints = routePoints;
                }

                // Update route display with snapped points
                updateRouteDisplay();

                // Add end marker
                const lastPoint = snappedRoutePoints.length > 0 ? snappedRoutePoints[snappedRoutePoints.length - 1] : routePoints[routePoints.length - 1];
                if (endMarker) {
                    map.removeLayer(endMarker);
                }
                endMarker = L.marker([lastPoint.lat, lastPoint.lng], {
                    icon: L.divIcon({
                        className: 'end-marker',
                        html: '<div style="background: #eb3349; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;"><i class="fas fa-flag" style="color: white; font-size: 10px;"></i></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(map);

                // Hide loading overlay
                document.getElementById('loadingOverlay').classList.remove('active');
                document.getElementById('statusText').textContent = 'Tracking stopped';
                document.getElementById('downloadBtn').disabled = false;
            } else {
                document.getElementById('statusText').textContent = 'Tracking stopped';
            }
        }

        // Update tracking map
        function updateTrackingMap(lat, lng) {
            // Update current position marker
            if (currentMarker) {
                currentMarker.setLatLng([lat, lng]);
            } else {
                currentMarker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'current-marker',
                        html: '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); width: 28px; height: 28px; border-radius: 50%; border: 3px solid white; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); display: flex; align-items: center; justify-content: center;"><i class="fas fa-location-arrow" style="color: white; font-size: 12px;"></i></div>',
                        iconSize: [28, 28],
                        iconAnchor: [14, 14]
                    })
                }).addTo(map);
            }

            // Add start marker if first point
            if (routePoints.length === 1 && !startMarker) {
                startMarker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'start-marker',
                        html: '<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;"><i class="fas fa-play" style="color: white; font-size: 10px;"></i></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(map);
            }

            // Update route polyline (show raw GPS points while tracking)
            if (routePoints.length > 1) {
                const coordinates = routePoints.map(p => [p.lat, p.lng]);
                
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                
                routePolyline = L.polyline(coordinates, {
                    color: '#667eea',
                    weight: 5,
                    opacity: 0.7,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(map);

                // Fit map to route (but keep zoom reasonable)
                const currentZoom = map.getZoom();
                if (currentZoom < 15) {
                    map.fitBounds(routePolyline.getBounds(), { padding: [50, 50], maxZoom: 18 });
                }
            }

            // Center map on current position
            map.setView([lat, lng], map.getZoom());
        }

        // Update route display with snapped points
        function updateRouteDisplay() {
            const pointsToUse = snappedRoutePoints.length > 0 ? snappedRoutePoints : routePoints;
            
            if (pointsToUse.length > 1) {
                const coordinates = pointsToUse.map(p => [p.lat, p.lng]);
                
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }
                
                routePolyline = L.polyline(coordinates, {
                    color: '#667eea',
                    weight: 6,
                    opacity: 0.9,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(map);

                map.fitBounds(routePolyline.getBounds(), { padding: [50, 50] });
            }
        }

        // Snap route to roads using OSRM Match service
        async function snapRouteToRoads() {
            if (routePoints.length < 2) {
                snappedRoutePoints = routePoints;
                return;
            }

            // Filter out duplicate or too-close points (minimum 5 meters apart)
            const MIN_DISTANCE_METERS = 5;
            const filteredPoints = [routePoints[0]]; // Always include first point
            
            for (let i = 1; i < routePoints.length; i++) {
                const lastPoint = filteredPoints[filteredPoints.length - 1];
                const currentPoint = routePoints[i];
                const distance = calculateDistance(
                    lastPoint.lat, lastPoint.lng,
                    currentPoint.lat, currentPoint.lng
                );
                
                // Only add point if it's far enough from the last point
                if (distance >= MIN_DISTANCE_METERS) {
                    filteredPoints.push(currentPoint);
                }
            }
            
            // Always include the last point
            if (filteredPoints.length > 0 && 
                filteredPoints[filteredPoints.length - 1] !== routePoints[routePoints.length - 1]) {
                filteredPoints.push(routePoints[routePoints.length - 1]);
            }

            // Need at least 2 distinct points
            if (filteredPoints.length < 2) {
                console.warn('Not enough distinct points for road snapping. Using original route.');
                snappedRoutePoints = routePoints;
                return;
            }

            // OSRM Match API requires coordinates in [lng, lat] format
            const coordinates = filteredPoints.map(p => [p.lng, p.lat]);
            
            // Build timestamps array - OSRM expects Unix timestamps in seconds
            // Convert milliseconds to seconds
            const timestamps = filteredPoints.map((p, i) => {
                const timestamp = p.timestamp || Date.now();
                // Convert to seconds (Unix timestamp)
                return Math.floor(timestamp / 1000);
            });

            // Build the URL for OSRM Match service
            // We'll batch points if there are too many (OSRM has limits)
            const maxPointsPerRequest = 100;
            const batches = [];
            
            for (let i = 0; i < coordinates.length; i += maxPointsPerRequest) {
                batches.push({
                    startIdx: i,
                    coords: coordinates.slice(i, Math.min(i + maxPointsPerRequest, coordinates.length)),
                    timestamps: timestamps.slice(i, Math.min(i + maxPointsPerRequest, timestamps.length)),
                    originalIndices: Array.from({length: Math.min(maxPointsPerRequest, coordinates.length - i)}, (_, j) => i + j)
                });
            }

            snappedRoutePoints = [];

            for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {
                const batch = batches[batchIdx];
                
                // Skip batches with duplicate coordinates
                const uniqueCoords = [];
                const uniqueTimestamps = [];
                const seen = new Set();
                
                for (let i = 0; i < batch.coords.length; i++) {
                    const coordKey = `${batch.coords[i][0]},${batch.coords[i][1]}`;
                    if (!seen.has(coordKey)) {
                        seen.add(coordKey);
                        uniqueCoords.push(batch.coords[i]);
                        uniqueTimestamps.push(batch.timestamps[i]);
                    }
                }
                
                // Need at least 2 unique points
                if (uniqueCoords.length < 2) {
                    console.warn('Batch has duplicate coordinates, using original points');
                    const startIdx = batch.startIdx;
                    const endIdx = Math.min(startIdx + maxPointsPerRequest, filteredPoints.length);
                    snappedRoutePoints = snappedRoutePoints.concat(filteredPoints.slice(startIdx, endIdx));
                    continue;
                }
                
                const coordsString = uniqueCoords.map(c => `${c[0]},${c[1]}`).join(';');
                const timestampsString = uniqueTimestamps.join(';');
                
                const url = `https://router.project-osrm.org/match/v1/driving/${coordsString}?timestamps=${timestampsString}&overview=full&geometries=geojson`;

                try {
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();

                    if (data.code === 'Ok' && data.matchings && data.matchings.length > 0) {
                        const geometry = data.matchings[0].geometry;
                        
                        // Convert GeoJSON coordinates [lng, lat] to [lat, lng] for Leaflet
                        if (geometry.type === 'LineString' && geometry.coordinates && geometry.coordinates.length > 0) {
                            const snappedCoords = geometry.coordinates.map((coord, idx) => {
                                // Try to preserve original timestamp if possible
                                const originalIdx = Math.floor((idx / geometry.coordinates.length) * uniqueTimestamps.length);
                                const timestamp = uniqueTimestamps[originalIdx] ? uniqueTimestamps[originalIdx] * 1000 : Date.now();
                                
                                return {
                                    lat: coord[1],
                                    lng: coord[0],
                                    timestamp: timestamp
                                };
                            });
                            snappedRoutePoints = snappedRoutePoints.concat(snappedCoords);
                        } else {
                            // Fallback: use original points
                            const startIdx = batch.startIdx;
                            const endIdx = Math.min(startIdx + maxPointsPerRequest, filteredPoints.length);
                            snappedRoutePoints = snappedRoutePoints.concat(filteredPoints.slice(startIdx, endIdx));
                        }
                    } else {
                        console.warn('OSRM matching failed:', data.code, data.message || 'Unknown error');
                        // Fallback: use original points for this batch
                        const startIdx = batch.startIdx;
                        const endIdx = Math.min(startIdx + maxPointsPerRequest, filteredPoints.length);
                        snappedRoutePoints = snappedRoutePoints.concat(filteredPoints.slice(startIdx, endIdx));
                    }
                } catch (error) {
                    console.error('Error in batch snapping:', error);
                    // Fallback: use original points for this batch
                    const startIdx = batch.startIdx;
                    const endIdx = Math.min(startIdx + maxPointsPerRequest, filteredPoints.length);
                    snappedRoutePoints = snappedRoutePoints.concat(filteredPoints.slice(startIdx, endIdx));
                }
            }

            // Ensure we have at least the start and end points
            if (snappedRoutePoints.length === 0) {
                console.warn('No snapped points generated, using original route');
                snappedRoutePoints = routePoints;
            } else {
                // Ensure first and last points match original
                if (snappedRoutePoints.length > 0 && routePoints.length > 0) {
                    snappedRoutePoints[0] = routePoints[0];
                    snappedRoutePoints[snappedRoutePoints.length - 1] = routePoints[routePoints.length - 1];
                }
            }
        }

        // Calculate and update distance
        function updateDistance() {
            const pointsToUse = snappedRoutePoints.length > 0 ? snappedRoutePoints : routePoints;
            
            if (pointsToUse.length < 2) {
                return;
            }

            let totalDistance = 0;
            for (let i = 1; i < pointsToUse.length; i++) {
                totalDistance += calculateDistance(
                    pointsToUse[i - 1].lat,
                    pointsToUse[i - 1].lng,
                    pointsToUse[i].lat,
                    pointsToUse[i].lng
                );
            }

            // Convert to kilometers
            const distanceKm = totalDistance / 1000;
            document.getElementById('distance').textContent = distanceKm.toFixed(2);
        }

        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                     Math.cos(œÜ1) * Math.cos(œÜ2) *
                     Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        // Start timer
        function startTimer() {
            timerInterval = setInterval(() => {
                if (startTime) {
                    const elapsed = Date.now() - startTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('time').textContent = 
                        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }

        // Stop timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Download route as JSON file
        function downloadRoute() {
            const pointsToUse = snappedRoutePoints.length > 0 ? snappedRoutePoints : routePoints;
            
            if (pointsToUse.length === 0) {
                alert('No route data to download.');
                return;
            }

            // Calculate total distance using snapped points
            let totalDistance = 0;
            for (let i = 1; i < pointsToUse.length; i++) {
                totalDistance += calculateDistance(
                    pointsToUse[i - 1].lat,
                    pointsToUse[i - 1].lng,
                    pointsToUse[i].lat,
                    pointsToUse[i].lng
                );
            }

            // Calculate duration
            const duration = startTime ? Date.now() - startTime : 0;

            // Create route data object
            const routeData = {
                version: '1.0',
                date: new Date().toISOString(),
                startTime: startTime ? new Date(startTime).toISOString() : null,
                endTime: new Date().toISOString(),
                duration: duration, // milliseconds
                distance: totalDistance, // meters
                snappedToRoads: snappedRoutePoints.length > 0,
                points: pointsToUse,
                originalPoints: routePoints // Keep original for reference
            };

            // Convert to JSON
            const json = JSON.stringify(routeData, null, 2);

            // Create blob and download
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${new Date().toISOString().split('T')[0]}_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Load route file
        function loadRouteFile(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            document.getElementById('viewLoadingOverlay').classList.add('active');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const routeData = JSON.parse(e.target.result);
                    displayRoute(routeData);
                    document.getElementById('viewLoadingOverlay').classList.remove('active');
                } catch (error) {
                    document.getElementById('viewLoadingOverlay').classList.remove('active');
                    alert('Error reading route file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Display route on view map
        function displayRoute(routeData) {
            if (!viewMap) {
                initViewMap();
            }

            // Clear previous route
            if (viewRoutePolyline) {
                viewMap.removeLayer(viewRoutePolyline);
            }
            if (startMarker) {
                viewMap.removeLayer(startMarker);
            }
            if (endMarker) {
                viewMap.removeLayer(endMarker);
            }

            // Use snapped points if available, otherwise use original points
            const points = routeData.points || [];
            
            if (points.length === 0) {
                alert('Route file contains no points.');
                return;
            }

            // Extract coordinates
            const coordinates = points.map(p => [p.lat, p.lng]);

            // Draw route polyline
            viewRoutePolyline = L.polyline(coordinates, {
                color: '#667eea',
                weight: 6,
                opacity: 0.9,
                lineCap: 'round',
                lineJoin: 'round'
            }).addTo(viewMap);

            // Add start marker
            const startPoint = points[0];
            startMarker = L.marker([startPoint.lat, startPoint.lng], {
                icon: L.divIcon({
                    className: 'start-marker',
                    html: '<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;"><i class="fas fa-play" style="color: white; font-size: 10px;"></i></div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                })
            }).addTo(viewMap);

            // Add end marker
            const endPoint = points[points.length - 1];
            endMarker = L.marker([endPoint.lat, endPoint.lng], {
                icon: L.divIcon({
                    className: 'end-marker',
                    html: '<div style="background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;"><i class="fas fa-flag" style="color: white; font-size: 10px;"></i></div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                })
            }).addTo(viewMap);

            // Fit map to route
            viewMap.fitBounds(viewRoutePolyline.getBounds(), { padding: [50, 50] });

            // Update route info
            const distance = routeData.distance ? (routeData.distance / 1000).toFixed(2) : '0.00';
            const duration = routeData.duration ? formatDuration(routeData.duration) : '00:00';
            const date = routeData.date ? new Date(routeData.date).toLocaleString() : 'Unknown';

            document.getElementById('viewDistance').textContent = distance + ' km';
            document.getElementById('viewTime').textContent = duration;
            document.getElementById('viewPoints').textContent = points.length;
            document.getElementById('viewDate').textContent = date;

            // Show route info and hide empty state
            document.getElementById('routeInfo').style.display = 'block';
            document.getElementById('emptyState').style.display = 'none';
        }

        // Format duration in milliseconds to MM:SS
        function formatDuration(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // ============================================
        // DEBUG FUNCTIONS - Available in Console
        // ============================================
        // Use these functions in the browser console to test the route tracker
        
        // Add a single GPS point manually (for testing)
        window.debugAddPoint = function(lat, lng, accuracy = 10) {
            if (!isTracking) {
                console.log('‚ö†Ô∏è Tracking is not active. Starting tracking...');
                startTracking();
            }
            
            const point = {
                lat: parseFloat(lat),
                lng: parseFloat(lng),
                accuracy: accuracy,
                timestamp: Date.now()
            };
            
            routePoints.push(point);
            updateTrackingMap(point.lat, point.lng);
            updateDistance();
            
            console.log(`‚úÖ Added point: ${point.lat}, ${point.lng}`);
            return point;
        };
        
        // Simulate a route with multiple points (for testing)
        window.debugSimulateRoute = function(startLat, startLng, endLat, endLng, numPoints = 10) {
            console.log('üß™ Simulating route...');
            
            if (!isTracking) {
                startTracking();
            }
            
            const points = [];
            const latStep = (endLat - startLat) / (numPoints - 1);
            const lngStep = (endLng - startLng) / (numPoints - 1);
            
            for (let i = 0; i < numPoints; i++) {
                const lat = startLat + (latStep * i);
                const lng = startLng + (lngStep * i);
                
                const point = {
                    lat: lat,
                    lng: lng,
                    accuracy: 10,
                    timestamp: Date.now() + (i * 1000) // 1 second apart
                };
                
                routePoints.push(point);
                points.push(point);
                
                // Update map after a short delay to see the route being drawn
                setTimeout(() => {
                    updateTrackingMap(lat, lng);
                    updateDistance();
                }, i * 100);
            }
            
            console.log(`‚úÖ Simulated route with ${numPoints} points`);
            console.log(`üìç Start: ${startLat}, ${startLng}`);
            console.log(`üìç End: ${endLat}, ${endLng}`);
            return points;
        };
        
        // Simulate a rectangular route (for testing)
        window.debugSimulateRectangularRoute = function(centerLat, centerLng, width = 0.01, height = 0.01, pointsPerSide = 5) {
            console.log('üß™ Simulating rectangular route...');
            
            if (!isTracking) {
                startTracking();
            }
            
            // Calculate corners
            const top = centerLat + (height / 2);
            const bottom = centerLat - (height / 2);
            const right = centerLng + (width / 2);
            const left = centerLng - (width / 2);
            
            const route = [
                // Top edge (left to right)
                ...Array.from({length: pointsPerSide}, (_, i) => ({
                    lat: top,
                    lng: left + (right - left) * (i / (pointsPerSide - 1))
                })),
                // Right edge (top to bottom)
                ...Array.from({length: pointsPerSide}, (_, i) => ({
                    lat: top - (top - bottom) * (i / (pointsPerSide - 1)),
                    lng: right
                })).slice(1), // Skip first point (already added)
                // Bottom edge (right to left)
                ...Array.from({length: pointsPerSide}, (_, i) => ({
                    lat: bottom,
                    lng: right - (right - left) * (i / (pointsPerSide - 1))
                })).slice(1), // Skip first point
                // Left edge (bottom to top)
                ...Array.from({length: pointsPerSide}, (_, i) => ({
                    lat: bottom + (top - bottom) * (i / (pointsPerSide - 1)),
                    lng: left
                })).slice(1, -1) // Skip first and last points
            ];
            
            route.forEach((coord, i) => {
                const point = {
                    lat: coord.lat,
                    lng: coord.lng,
                    accuracy: 10,
                    timestamp: Date.now() + (i * 1000)
                };
                
                routePoints.push(point);
                
                setTimeout(() => {
                    updateTrackingMap(point.lat, point.lng);
                    updateDistance();
                }, i * 100);
            });
            
            console.log(`‚úÖ Simulated rectangular route with ${route.length} points`);
            return route;
        };
        
        // Clear all route points (for testing)
        window.debugClearRoute = function() {
            routePoints = [];
            snappedRoutePoints = [];
            
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            if (currentMarker) {
                map.removeLayer(currentMarker);
                currentMarker = null;
            }
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            
            document.getElementById('distance').textContent = '0.00';
            document.getElementById('time').textContent = '00:00';
            
            console.log('‚úÖ Route cleared');
        };
        
        // Get current route points (for debugging)
        window.debugGetRoutePoints = function() {
            console.log(`üìç Total points: ${routePoints.length}`);
            console.log(`üìç Snapped points: ${snappedRoutePoints.length}`);
            console.log('üìç Route points:', routePoints);
            return routePoints;
        };
        
        // Simulate movement along a path (for testing)
        window.debugSimulateMovement = function(path, interval = 1000) {
            if (!Array.isArray(path) || path.length === 0) {
                console.error('‚ùå Path must be an array of {lat, lng} objects');
                return;
            }
            
            console.log(`üß™ Simulating movement along ${path.length} points...`);
            
            if (!isTracking) {
                startTracking();
            }
            
            let index = 0;
            const moveInterval = setInterval(() => {
                if (index >= path.length) {
                    clearInterval(moveInterval);
                    console.log('‚úÖ Movement simulation complete');
                    return;
                }
                
                const point = path[index];
                window.debugAddPoint(point.lat, point.lng);
                index++;
            }, interval);
            
            return moveInterval;
        };
        
        // Print debug info
        window.debugInfo = function() {
            console.log('=== Route Tracker Debug Info ===');
            console.log(`Tracking: ${isTracking ? '‚úÖ Active' : '‚ùå Inactive'}`);
            console.log(`Route Points: ${routePoints.length}`);
            console.log(`Snapped Points: ${snappedRoutePoints.length}`);
            console.log(`Start Time: ${startTime ? new Date(startTime).toLocaleString() : 'N/A'}`);
            console.log(`Current Distance: ${document.getElementById('distance').textContent} km`);
            console.log(`Current Time: ${document.getElementById('time').textContent}`);
            console.log('\n=== Available Debug Functions ===');
            console.log('debugAddPoint(lat, lng, accuracy) - Add a single GPS point');
            console.log('debugSimulateRoute(startLat, startLng, endLat, endLng, numPoints) - Simulate a straight route');
            console.log('debugSimulateRectangularRoute(centerLat, centerLng, width, height, pointsPerSide) - Simulate a rectangular route');
            console.log('debugSimulateMovement(path, interval) - Simulate movement along a path');
            console.log('debugClearRoute() - Clear all route points');
            console.log('debugGetRoutePoints() - Get all route points');
            console.log('debugInfo() - Show this help');
            console.log('\n=== Example Usage ===');
            console.log('debugAddPoint(-37.8136, 144.9631);');
            console.log('debugSimulateRoute(-37.8136, 144.9631, -37.8200, 144.9700, 20);');
            console.log('debugSimulateRectangularRoute(-37.8136, 144.9631, 0.01, 0.01, 10);');
        };
        
        // Show debug info on load
        console.log('%cüîß Route Tracker Debug Mode', 'color: #667eea; font-size: 16px; font-weight: bold;');
        console.log('%cType debugInfo() in the console to see available debug functions', 'color: #666; font-size: 12px;');

        // Initialize on page load
        window.onload = function() {
            initTrackingMap();
        };
    </script>
</body>
</html>
